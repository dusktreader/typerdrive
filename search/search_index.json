{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#typerdrive","title":"typerdrive","text":"<p>Develop API-Connected Typer Apps at Lightspeed</p>"},{"location":"#overview","title":"Overview","text":"<p>This Python package adds extended functionality for Typer CLIs.</p> <p>Many features are planned, but these are the ones that are available thus far:</p> <ul> <li>Settings management &amp; commands</li> <li>Cache management &amp; commands</li> <li>Logging management &amp; commands</li> <li>User-friendly error handling</li> <li>Powered Up API clients</li> </ul>"},{"location":"demo/","title":"Demo","text":"<p>The <code>typerdrive</code> package includes an \"extra\" that can be installed to show all its features. Each demo focuses on a particular feature and runs a few examples that demonstrate how the feature can be used in your CLI app.</p>"},{"location":"demo/#installation","title":"Installation","text":"<p>To install the <code>demo</code> with <code>typerdrive</code> you need to supply it as an \"extra\" when installing <code>typerdrive</code>. The following command can be used:</p> <pre><code>pip install typerdrive[demo]\n</code></pre>"},{"location":"demo/#running-the-demo","title":"Running the demo","text":"<p>An entrypoint for the demo is included when it is installed. Simply run:</p> <pre><code>typerdrive-demo\n</code></pre> <p>If you provide no arguments, it will run all available demos. If you wish to only see the demos for a particular feature, you can use the <code>--feature=&lt;feature&gt;</code> option to target one feature.</p> <p>To see all available options, run:</p> <pre><code>typerdrive-demo --help\n</code></pre>"},{"location":"demo/#running-the-demo-in-an-isolated-environment-with-uv","title":"Running the demo in an isolated environment with uv","text":"<p>If you want to run the demo but not include its dependencies in your system python or an activated virtual environment, you can execute the demo with uv:</p> <pre><code>uvx --from=typerdrive[demo] typerdrive-demo\n</code></pre>"},{"location":"demo/#check-out-the-source","title":"Check out the source","text":"<p>You can also examine the demo source to examine how <code>typerdrive</code> is used.</p> <p>Check out the source code on Github.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 to 3.13</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#install-from-pypi","title":"Install from pypi:","text":"<p>This will install the latest release from pypi via pip:</p> <pre><code>pip install typerdrive\n</code></pre> <p>To include the runnable demo, you need to include the <code>demo</code> extra:</p> <pre><code>pip install typerdrive[demo]\n</code></pre>"},{"location":"features/cache/","title":"Commands to manage application cache","text":"<p>Because basic <code>Typer</code> apps are essentially stateless, there isn't a good way to temporarily store data. A cache can be useful when you want to keep data between sessions, but the functionality of your app isn't dependent on the data staying there. Auth tokens are a great example of this. If your app authenticates against an identity provider, you probably don't want to have to login every time you run a command in your app.</p> <p>A cache allows you to store your tokens between commands. Because you can always get new tokens by logging in again, they fit well with the ephemeral nature of a cache.</p> <p>To provide this functionality, <code>typerdrive</code> provides a cache manager and the <code>cache</code> subcommand to manage your app's cache.</p>"},{"location":"features/cache/#overview","title":"Overview","text":"<p>The <code>typerdrive</code> package provides the functionality to store, retrieve, and clear three types of data:</p> <ul> <li>binary data</li> <li>text data</li> <li>json data</li> </ul> <p>To gain access to your cache, you can retrieve the <code>CacheManager</code> that is bound to the user context through the use of the <code>@attach_cache</code> decorator by providing an argument to your command with the <code>CacheManager</code> type.</p> <p>The type is important!</p> <p>The type for you \"manager\" argument must be <code>CacehManager</code>, or Typer will throw an error!</p> <p>You can also view your cache at any time and clear one or all of the data in it through <code>cache</code> subcommands.</p>"},{"location":"features/cache/#usage","title":"Usage","text":"<p>It's useful to start with a code example to see the cache in action:</p> <pre><code>from random import choice\n\nimport typer\nfrom rich import print\nfrom rich.panel import Panel\nfrom snick import unwrap\nfrom typerdrive import CacheError, CacheManager, add_cache_subcommand, attach_cache, set_typerdrive_config\nfrom typerdrive.env import tweak_env\n\ncli = typer.Typer()\nadd_cache_subcommand(cli)\nset_typerdrive_config(app_name=\"cache-commands-example\")\n\nspeeches = dict(\n    yoda=unwrap(\n        \"\"\"\n        Size matters not. Look at me. Judge me by my size, do you? Hmm? Hmm. And well you should not. For my ally is the\n        Force, and a powerful ally it is. Life creates it, makes it grow. Its energy surrounds us and binds us. Luminous\n        beings are we, not this crude matter. You must feel the Force around you; here, between you, me, the tree, the\n        rock, everywhere, yes. Even between the land and the ship.\n        \"\"\"\n    ),\n    leia=unwrap(\n        \"\"\"\n        General Kenobi. Years ago you served my father in the Clone Wars. Now he begs you to help him in his struggle\n        against the Empire. I regret that I am unable to present my father's request to you in person, but my ship has\n        fallen under attack, and now I'm afraid my mission to bring you to Alderaan has failed.  I have placed\n        information vital of the survival of the Rebellion into the memory systems of this R2 unit.My father will know\n        how to retrieve it. You must see this droid safely delivered to him on Alderaan. This is our most desperate\n        hour. Help me, Obi-Wan Kenobi. You're my only hope.\n        \"\"\"\n    ),\n    han=unwrap(\n        \"\"\"\n        Kid, I've flown from one side of this galaxy to the other; I've seen a lot of strange stuff. But I've never seen\n        anything to make me believe that there's one all-powerful Force controlling everything. There's no mystical\n        energy field that controls my destiny. Anyway, it's all a lot of simple tricks and nonsense.\n        \"\"\"\n    ),\n)\n\n\n@cli.command()\n@attach_cache()\ndef report(ctx: typer.Context, manager: CacheManager):  # pyright: ignore[reportUnusedParameter]\n    speaker = choice(list(speeches.keys()))\n    path = f\"{speaker}/speech.txt\"\n    used_cache = False\n    text: str\n    try:\n        text = manager.load_text(path)\n    except CacheError:\n        print(f\"[red]Cache miss![/red] Loading text for {speaker}\")\n        text = speeches[speaker]\n    else:\n        print(f\"[green]Cache hit![/green] Loaded text from cache target [yellow]{path}[/yellow]\")\n        used_cache = True\n\n    with tweak_env(COLUMNS=\"80\"):\n        print(Panel(text))\n\n    if not used_cache:\n        manager.store_text(text, path)\n        print(f\"Stored text at cache target [yellow]{path}[/yellow]\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>In this toy example, some text is stored in the cache to be used for future executions of the <code>report</code> command.</p> <p>If the data isn't in the cache yet, it's \"loaded\". The data is printed and then stored in the cache for future use:</p> <pre><code>$ python examples/cache/commands.py report\nCache miss! Loading text...\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Size matters not. Look at me. Judge me by my size, do you? Hmm? Hmm. And     \u2502\n\u2502 well you should not. For my ally is the Force, and a powerful ally it is.    \u2502\n\u2502 Life creates it, makes it grow. Its energy surrounds us and binds us.        \u2502\n\u2502 Luminous beings are we, not this crude matter. You must feel the Force       \u2502\n\u2502 around you; here, between you, me, the tree, the rock, everywhere, yes. Even \u2502\n\u2502 between the land and the ship.                                               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nStored text at cache target yoda/speech.txt\n</code></pre> <p>When you run the command again, the data is retrieved from the cache instead:</p> <pre><code>$ python examples/cache/commands.py report\nCache hit! Loaded text from cache target yoda/speech.txt\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Size matters not. Look at me. Judge me by my size, do you? Hmm? Hmm. And     \u2502\n\u2502 well you should not. For my ally is the Force, and a powerful ally it is.    \u2502\n\u2502 Life creates it, makes it grow. Its energy surrounds us and binds us.        \u2502\n\u2502 Luminous beings are we, not this crude matter. You must feel the Force       \u2502\n\u2502 around you; here, between you, me, the tree, the rock, everywhere, yes. Even \u2502\n\u2502 between the land and the ship.                                               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>This time, the data was found in the cache so it was loaded from there.</p> <p>Running the command a few more times will eventually store all the speeches in the cache. Now, you can view the cache if to see what has been saved in it:</p> <pre><code>$ python examples/cache/commands.py cache show\n\u256d\u2500 Current cache \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502 \ud83d\udcc2 /home/dusktreader/.cache/commands.py                                      \u2502\n\u2502 \u251c\u2500\u2500 \ud83d\udcc2 han                                                                   \u2502\n\u2502 \u2502   \u2514\u2500\u2500 \ud83d\udcc4 speech.txt (313 Bytes)                                            \u2502\n\u2502 \u251c\u2500\u2500 \ud83d\udcc2 leia                                                                  \u2502\n\u2502 \u2502   \u2514\u2500\u2500 \ud83d\udcc4 speech.txt (594 Bytes)                                            \u2502\n\u2502 \u2514\u2500\u2500 \ud83d\udcc2 yoda                                                                  \u2502\n\u2502     \u2514\u2500\u2500 \ud83d\udcc4 speech.txt (395 Bytes)                                            \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Storing 1.3 kB in 3 files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Let's say that we only want to remove a single item from the cache. We can do that using the <code>clear</code> command with a path for the cache item. In this case, let's remove yoda's speech:</p> <pre><code>$ python examples/cache/commands.py cache clear --path=yoda/speech.txt\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Cleared entry at cache target yoda/speech.txt                              \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Let's view the cache again to verify that the file was removed:</p> <pre><code>$ python examples/cache/commands.py cache show\n\n\u256d\u2500 Current cache \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502 \ud83d\udcc2 /home/dusktreader/.cache/commands.py                                      \u2502\n\u2502 \u251c\u2500\u2500 \ud83d\udcc2 han                                                                   \u2502\n\u2502 \u2502   \u2514\u2500\u2500 \ud83d\udcc4 speech.txt (313 Bytes)                                            \u2502\n\u2502 \u2514\u2500\u2500 \ud83d\udcc2 leia                                                                  \u2502\n\u2502     \u2514\u2500\u2500 \ud83d\udcc4 speech.txt (594 Bytes)                                            \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Storing 907 Bytes in 2 files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Great! Now, we could go through and clean the remaining files up one at a time. But, the <code>clear</code> command will empty the whole cache out if you run it without a specific path:</p> <pre><code>$ python examples/cache/commands.py cache clear\nAre you sure you want to clear the entire cache? [y/N]: y\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Cleared all 2 files from cache                                             \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Note that you have to confirm whenever you request to clear the entire cache to prevent accidental deletion.</p>"},{"location":"features/cache/#details","title":"Details","text":"<p>Let's take a closer look at the details of each <code>cache</code> subcommand and the methods of the <code>CacheManager</code>:</p>"},{"location":"features/cache/#cache-sub-commands","title":"<code>cache</code> sub-commands","text":"<p>The <code>cache</code> command provides two sub-commands to manage the cache.</p>"},{"location":"features/cache/#clear","title":"<code>clear</code>","text":"<p>The <code>clear</code> command gives you the ability to remove items from the cache. You can target a specific entry in the cache by passing it a specific path using the <code>--path</code> option. If the item is not found in the cache at that location, an error will be raised. If it is found, the item will be deleted.</p> <p>If no path is provided to the <code>clear</code> command, then the entire cache will be cleared out. You are required to confirm your action to make sure that mistakes are not made.</p> <p>The help text from the <code>clear</code> command looks like this:</p> <pre><code>$ python examples/cache/commands.py cache clear --help\n\n Usage: commands.py cache clear [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --path        TEXT  Clear only the entry matching this path. If not provided,\u2502\n\u2502                     clear the entire cache [default: None]                   \u2502\n\u2502 --help              Show this message and exit.                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"features/cache/#show","title":"<code>show</code>","text":"<p>The <code>show</code> command just shows the current state of the cache. It will show the entire tree structure of the data stored in the cache and a report about how big the cache is and how many files are stored in it.</p>"},{"location":"features/cache/#the-get_cache_manager-function","title":"The <code>get_cache_manager()</code> function","text":"<p>The <code>attach</code> submodule of <code>typerdrive.cache</code> provides a <code>get_cache_manager()</code> function. If you want to avoid the magic of using a parameter to your command with the <code>CacheManager</code> type, you can get access to the <code>CacheManager</code> instance from the <code>typer.Context</code> using the <code>get_cache_manager()</code> function instead.</p>"},{"location":"features/cache/#cachemanager-methods","title":"<code>CacheManager</code> methods","text":"<p>The <code>CacheManager</code> provides several methods for interacting with the cache.</p>"},{"location":"features/cache/#cachemanagerresolve_path","title":"<code>CacheManager.resolve_path()</code>","text":"<p>This method converts a cache target path like <code>yoda/speech.txt</code> into the absolute path to the file where the data is stored. It does several checks to make sure that the file exists and that the resolved path is actually within the cache directory (to prevent sneaky use of <code>..</code>).</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerlist_items","title":"<code>CacheManager.list_items()</code>","text":"<p>This method shows all the items stored in a path within the cache. It will only list files, not directories. If the target path does not exist or is not a directory, an exception will be raised.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerstore_bytes","title":"<code>CacheManager.store_bytes()</code>","text":"<p>This method stores binary data in a cache target. An optional <code>mode</code> keyword argument can be provided to control the permissions of the cache entry. So, for example, if you want only your user to be able to read and write to the entry, you might use a <code>mode</code> of <code>0o600</code>.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerstore_text","title":"<code>CacheManager.store_text()</code>","text":"<p>This method stores text data in a cache target. It can also be given a <code>mode</code> parameter.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerstore_json","title":"<code>CacheManager.store_json()</code>","text":"<p>This method stores a dictionary of data in a cache target. The dictionary must be JSON serializable or an error will be thrown. The JSON written to the file is formatted to be human readable. This method can also be provided a <code>mode</code> parameter.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerload_bytes","title":"<code>CacheManager.load_bytes()</code>","text":"<p>This method loads binary data from a cache target. If the cache target does not exist, an error will be thrown.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerload_text","title":"<code>CacheManager.load_text()</code>","text":"<p>This method loads text data from a cache target. If the cache target does not exist, an error will be thrown.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerload_json","title":"<code>CacheManager.load_json()</code>","text":"<p>This method loads a JSON serialized dictionary from a cache target. If the cache target does not exist, an error will be thrown. If the data at the cache target cannot be serialized, an error will be thrown.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerclear_path","title":"<code>CacheManager.clear_path()</code>","text":"<p>This method removes an entry from the cache at the provided target. If the target does not exist, an error will be thrown. If the parent directory of the entry is empty after it is removed, the parent directory will be removed as well.</p> <p>Method Reference</p>"},{"location":"features/cache/#cachemanagerclear_all","title":"<code>CacheManager.clear_all()</code>","text":"<p>This method will remove all items from the cache.</p> <p>Method Reference</p>"},{"location":"features/client/","title":"API Clients with some special modifications","text":"<p>More sophisticated CLI applications often need to talk to one or more remote APIs. To help you with that, <code>typerdrive</code> includes a client that can be attached to any command using the <code>@attach_client()</code>. The client can load its configuration from the settings if they are attached.</p> <p>Additionally, the client provided by <code>typerdrive</code> has some specialized features called the <code>*_x()</code> methods that provide some useful scaffolding around the standard <code>httpx</code> query functions.</p>"},{"location":"features/client/#overview","title":"Overview","text":"<p>The <code>typerdrive</code> package provides the <code>@attach_client()</code> decorator that allows you to access instances of <code>TyperdriveClient</code> as arguments to your command function. The <code>TyperdriveClient</code> inherits from <code>httpx.Client</code> and adds the following enhancements through the <code>*_x()</code> methods:</p> <ul> <li>Ability to specify the query parameters as a <code>pydantic</code> model instance</li> <li>Ability to specify the request body as a <code>pydantic</code> model instance</li> <li>Ability to provide an expected status (an exception will be raised if it does not match)</li> <li>Ability to provide a <code>pydantic</code> model class to deserialize the response into</li> </ul> <p>The <code>@attach_client()</code> decorator also makes it easy to initialize the instances of the <code>TyperdriveClient</code> using values from your settings model provided through <code>@attach_settings()</code>.</p>"},{"location":"features/client/#usage","title":"Usage","text":"<p>Let's look at a code example to see how the <code>@attach_client()</code> decorator and <code>TyperdriveClient</code> can be used:</p> <pre><code>from typing import Annotated\n\nimport typer\nfrom pydantic import BaseModel\nfrom typerdrive import (\n    TyperdriveClient,\n    attach_client,\n    attach_settings,\n    handle_errors,\n    set_typerdrive_config,\n    terminal_message,\n)\n\n\nclass SettingsModel(BaseModel):\n    people_url: str = \"https://swapi.info/api/people\"\n    planets_url: str = \"https://swapi.info/api/planets\"\n\n\nclass PeopleResponse(BaseModel, extra=\"ignore\"):\n    name: str\n    height: int\n    birth_year: str\n    gender: str\n\n\nclass PlanetResponse(BaseModel, extra=\"ignore\"):\n    name: str\n    climate: str\n    terrain: str\n    gravity: str\n    population: int\n\n\ncli = typer.Typer()\nset_typerdrive_config(app_name=\"cache-commands-example\")\n\n\n@cli.command()\n@handle_errors(\"Lookup on SWAPI failed!\")\n@attach_settings(SettingsModel)\n@attach_client(people=\"people_url\", planets=\"planets_url\")\ndef report(\n    ctx: typer.Context,  # pyright: ignore[reportUnusedParameter]\n    people: TyperdriveClient,\n    planets: TyperdriveClient,\n    person_id: Annotated[int, typer.Option(help=\"The ID of the person to look up\")] = 1,\n    planet_id: Annotated[int, typer.Option(help=\"The ID of the planet to look up\")] = 1,\n):\n    terminal_message(\n        str(people.get_x(f\"{person_id}\", expected_status=200, response_model=PeopleResponse)),\n        subject=f\"Person {person_id}\",\n        footer=f\"Fetched from {people.base_url}{person_id}\",\n    )\n    terminal_message(\n        str(planets.get_x(f\"{planet_id}\", expected_status=200, response_model=PlanetResponse)),\n        subject=f\"Planet {planet_id}\",\n        footer=f\"Fetched from {planets.base_url}{planet_id}\",\n    )\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>In this example, we are attaching two separate clients that both connect to the Star Wars API (SWAPI). Both clients utilize a base url provided in the settings. Finally, both clients are accessed in the command function body by providing a <code>TyperdriveClient</code> argument with a name that matches the keyword arguments in <code>@attach_client()</code>.</p> <p>When we run the example, the two clients will load some data from the API and show it on the screen:</p> <pre><code>$ python examples/client/attach.py\n\n\u256d\u2500 Person 1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   name='Luke Skywalker' height=172 birth_year='19BBY' gender='male'          \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Fetched from https://swapi.info/api/people/1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\n\u256d\u2500 Planet 1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   name='Tatooine' climate='arid' terrain='desert' gravity='1 standard'       \u2502\n\u2502   population=200000                                                          \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Fetched from https://swapi.info/api/planets/1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As you can see, because client requests included a <code>response_model</code> keyword argument, the returned data was automatically deserialized into the provided <code>pydantic</code> model.</p> <p>The client also provides error checking that can work hand-in-hand with the <code>@handle_errors()</code> decorator so that if the request provides the wrong response code, response data type, or incorrectly formatted data you can have a helpful error message provided to your users:</p> <pre><code>$ python examples/client/attach.py --person-id=9000\n\n\u256d\u2500 Lookup on SWAPI failed! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Got an unexpected status code: Expected 200, got 404 -- Not Found          \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>In this case, we attempted to fetch a person that doesn't exist on <code>SWAPI</code>, consequently, the server returned a <code>404: Not Found</code> response. Since our request specified that a 200 was to be expected, an error was raised. That error was neatly handled by the <code>@handle_errors()</code> decorator and presented nicely to the user.</p>"},{"location":"features/client/#details","title":"Details","text":"<p>There are some important details to know about with the <code>TyperdriveClient</code> and the <code>@attach_client()</code> decorator that we'll go over now.</p>"},{"location":"features/client/#typerdriveclient","title":"<code>TyperdriveClient</code>","text":"<p>The <code>TyperdriveClient</code> is a very thin layer over the top of a normal <code>httpx.Client</code> instance. However, the <code>*_x()</code> methods provide a lot of extra functionality that, in my experience, are very nice to have when working with APIs in a CLI app.</p> <p>Let's go over the methods.</p>"},{"location":"features/client/#typerdriveclient__init__","title":"<code>TyperdriveClient.__init__()</code>","text":"<p>There is only one additional keyword argument added that the base <code>httpx.Client</code> doesn't have. It's the <code>log_func</code> parameter. If provided, the <code>TyperdriveClient</code> will use this function to log its behavior as it's processing a request. This is very useful for debugging issues with the requests.</p> <p>This parameter can be any function that acts on a string, but usually you would use a method from a <code>logging.Logger</code>, just the builtin <code>print</code> function, or (as I usually prefer) a <code>loguru.Logger</code> method. If it is not provided, the <code>TyperdriveClient</code> will use a builtin logger named <code>typerdrive.client</code> and log all its messages at a <code>DEBUG</code> level.</p> <p>Method Reference</p>"},{"location":"features/client/#typerdriveclientrequest_x","title":"<code>TyperdriveClient.request_x()</code>","text":"<p>This is the beating heart of the <code>TyperdriveClient</code>. The function will issue a request using <code>httpx.Client.request()</code>, but it provides a lot of functionality that is controlled by it's keyword arguments.</p> <p>The <code>TyperdriveClient</code> accepts all the same args and kwargs as it's parent <code>httpx.Client</code> (and passes them along at init time), but also accepts additional kwargs.</p> <p>Method Reference</p>"},{"location":"features/client/#param_obj","title":"<code>param_obj</code>","text":"<p>If provided, this should be an instance of a <code>pydantic</code> model. It will be deserialized into a dictionary that will be used for the request URL parameters. Suppose that a <code>GET</code> endpoint in your API supports query params <code>page</code>, <code>page_size</code>, <code>sort</code>, and <code>search</code>. You could use a pydantic model to describe the params like this:</p> <pre><code>class Params(BaseModel):\n    page: int = 0\n    page_size: int = 10\n    sort: bool = False\n    search: str = \"\"\n</code></pre> <p>and use an instance of it in your request:</p> <pre><code>client = TyperdriveClient()\nclient.request_x(\"GET\", \"/cities/mos-eisley\", param_obj=Params(sort=True, search=\"droids\"))\n</code></pre> <p>If user input is going to be used to drive the url parameters, using a <code>pydantic</code> model provides a very convenient validation mechanism.</p>"},{"location":"features/client/#body_obj","title":"<code>body_obj</code>","text":"<p>Like the <code>param_obj</code>, the <code>body_obj</code> parameter allows you to use an instance of a <code>pydantic</code> model to describe the body of the request that will be sent. Let's suppose now, that you have a <code>POST</code> endpoint that requires a specific format of data to create a new entity. You can use <code>pydantic</code> to structure and validate the data and let the <code>TyperdriveClient</code> correctly deserialize the data for its request.</p> <p>Suppose the endpoint needs a JSON structure like this in the <code>POST</code> request:</p> <pre><code>{\n  \"external\": {\n    \"casing\": \"durasteel\",\n    \"buttons\": 1\n  },\n  \"internal\": {\n    \"kyber_crystal\": \"green\",\n    \"emitter_shape\": \"cup\"\n  }\n}\n</code></pre> <p>Then, you might have <code>pydantic</code> models set up like this:</p> <pre><code>class ExternalParts(BaseModel):\n    casing: str = \"steel\"\n    buttons: int = 1\n\nclass InternalParts(BaseModel):\n    kyber_crystal: Color\n    emitter_shape: \"cup\"\n\nclass Lightsaber(BaseModel):\n    internal: InternalParts\n    external: ExternalParts\n</code></pre> <p>Finally, we could make our request using <code>request_x()</code> like this:</p> <pre><code>lightsaber_3 = Lightsaber(\n    internal=InternalParts(kyber_crystal=GREEN),\n    external=ExternalParts(casing=\"durasteel\"),\n)\nclient.request_x(\"POST\", \"/lightsaber\", body_obj=lightsaber_3)\n</code></pre>"},{"location":"features/client/#expected_status","title":"<code>expected_status</code>","text":"<p>If this parameter is provided, then the return status code from the request will be compared against this value. If it does not match, an exception will be raised.</p>"},{"location":"features/client/#expect_response","title":"<code>expect_response</code>","text":"<p>This flag indicates whether or not the request is expected to return a response. By default, the <code>request_x()</code> method expects to receive a JSON response from the server. If you know that the endpoint you are calling doesn't return a response, then you can pass <code>expect_response=False</code>, and the <code>request_x()</code> method will return the status code from the request only:</p> <pre><code>client.request_x(\"DELETE\", \"/death-star/tractor-beam\", expect_response=False)\n</code></pre>"},{"location":"features/client/#response_model","title":"<code>response_model</code>","text":"<p>This is probably the most useful feature of the <code>TyperdriveClient</code>. If you provide a <code>pydantic</code> model class with the <code>response_model</code> parameter, then the <code>request_x()</code> method will deserialize the response into an instance of that model. If deserialization fails, an exception will be raised explaining what went wrong.</p> <p>Consider an API endpoint that returns a payload like this:</p> <pre><code>{\n    \"total_amount\": 17000,\n    \"up_front\": 2000,\n    \"on_delivery\": 15000,\n    \"extras\": \"safe delivery\"\n}\n</code></pre> <p>We could create a model describing what we expect to receive from the API and use it in the request:</p> <pre><code>class TransportAgreement(BaseModel):\n   total_amount: int\n   up_front: int\n   on_delivery: int\n   extras: str | None\n\nclient.request_x(\"POST\", \"/smuggler\", response_model=TransportAgreement)\n</code></pre>"},{"location":"features/client/#typerdriveclientget_x","title":"<code>TyperdriveClient.get_x()</code>","text":"<p>This method simply calls <code>request_x()</code> with a fixed method of <code>GET</code>.</p> <p>Method Reference</p>"},{"location":"features/client/#typerdriveclientpost_x","title":"<code>TyperdriveClient.post_x()</code>","text":"<p>This method simply calls <code>request_x()</code> with a fixed method of <code>POST</code>.</p> <p>Method Reference</p>"},{"location":"features/client/#typerdriveclientput_x","title":"<code>TyperdriveClient.put_x()</code>","text":"<p>This method simply calls <code>request_x()</code> with a fixed method of <code>PUT</code>.</p> <p>Method Reference</p>"},{"location":"features/client/#typerdriveclientpatch_x","title":"<code>TyperdriveClient.patch_x()</code>","text":"<p>This method simply calls <code>request_x()</code> with a fixed method of <code>PATCH</code>.</p> <p>Method Reference</p>"},{"location":"features/client/#typerdriveclientdelete_x","title":"<code>TyperdriveClient.delete_x()</code>","text":"<p>This method simply calls <code>request_x()</code> with a fixed method of <code>DELETE</code>.</p> <p>Method Reference</p>"},{"location":"features/client/#attach_client","title":"<code>attach_client()</code>","text":"<p>The <code>attach_client()</code> decorator is used to bind instances of <code>TyperdriveClient</code> to the command context. It instantiates the client instances.</p> <p>It does this by mapping the keyword arguments (besides <code>log_func</code>) to new client instances.</p> <p>The keyword argument name will be the name of the newly created client. The value of the keyword argument is used to provide a <code>base_url</code> for the new client. The <code>attach_client()</code> decorator will first try to match the value with a settings value if the settings are attached to the context. If it can't find a matching settings value, then it will use the value itself as a <code>base_url</code>.</p> <p>Consider this example:</p> <pre><code>class SettingsModel(BaseModel):\n    people_api: str = \"https://swapi.info/api/people\"\n\ncli = typer.Typer()\n\n@cli.command()\n@attach_settings(SettingsModel)\n@attach_client(people=\"people_api\")\ndef report(ctx: typer.Context, people: TyperdriveClient):\n    ...\n</code></pre> <p>Here, the settings contain a value \"people_api\" that matches the value of the keyword argument. Thus, a new <code>TyperdriveClient</code> instance named \"people\" is created and bound to the context. Because we provided a parameter named <code>people</code> to the <code>report()</code> function, the new client will be available in the function body as a variable named <code>people</code>.</p> <p>Let's look at a different example:</p> <pre><code>class SettingsModel(BaseModel):\n    people_api: str = \"https://swapi.info/api/people\"\n\ncli = typer.Typer()\n\n@cli.command()\n@attach_settings(SettingsModel)\n@attach_client(planets=\"https://swapi.info/api/planets\")\ndef report(ctx: typer.Context, planets: TyperdriveClient):\n    ...\n</code></pre> <p>Because the value of the keyword argument to <code>@attach_client()</code> doesn't match any settings, the value will be used as the <code>base_url</code> for the \"planets\" client in the function body.</p> <p>Finally, let's look at one more example:</p> <pre><code>cli = typer.Typer()\n\n@cli.command()\n@handle_errors(\"Lookup on SWAPI failed!\")\n@attach_client(planets=\"planets_api\")\ndef report(ctx: typer.Context, planets: TyperdriveClient):\n    ...\n</code></pre> <p>In this case, we don't have a settings object bound. On its own, that won't be a problem. However, because no settings value can be matched to \"planets_api\", that value would be used for a <code>base_url</code>. Since \"planets_api\" is not a valid http/https URL, however, an exception will be raised:</p> <pre><code>\u256d\u2500 Lookup on SWAPI failed! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Couldn't use base_url='planets_url' for client. If using a settings key,   \u2502\n\u2502   make sure settings are attached.                                           \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Finally, it should be noted that if you pass a <code>log_func</code> value to the <code>@attach_client()</code> decorator, this will be passed to each client instance to use to log its work.</p> <p>Function Reference</p>"},{"location":"features/exceptions/","title":"User-friendly Error Handling","text":"<p>By default, <code>Typer</code> doesn't produce user-friendly errors. It does use <code>rich</code> to add some style to the exceptions out of the box. But, without any other error handling, your users will be confronted with a stack-trace and exception message that might be very difficult for them to interpret.</p>"},{"location":"features/exceptions/#overview","title":"Overview","text":"<p>The <code>typerdrive</code> package provides a convenient way to handle errors within your Typer app. Instead of slapping your users with a big stack-trace, <code>typerdrive</code> presents errors in a clean and friendly presentation so users can better understand what went wrong.</p> <pre><code>\u256d\u2500 Login Error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Couldn't log you in to https://wretched-hive-of-scum-and-villainy.com      \u2502                                                      \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 If the problem persists, please contact tech support \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can customize what errors are handled, which are ignored, and even add tasks that should be run by the error handler.</p> <p>The implementation of the <code>@handle_errors()</code> decorator was heavily influenced by the implementation of the <code>handle_errors()</code> context manager from the <code>py-buzz</code> package, and so it uses a lot of the same patterns.</p> <p>The <code>TyperdriveError</code> (and subclasses) provided in <code>typerdrive</code> is a subclass of the <code>Buzz</code> class from <code>py-buzz</code>. If you want to learn more about how to use <code>Buzz</code> classes, please checkout the linked documentation for <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#usage","title":"Usage","text":"<p>Let's start out by looking at an example that uses the <code>@handle_errors()</code> decorator:</p> <p>This one's more complicated!</p> <p>This example is a bit more complicated because there's more setup needed to show the full breadth of the <code>@handle_errors()</code> decorator. The meat of the command function starts on line 49.</p> <pre><code>import random\nimport traceback\nfrom enum import StrEnum, auto\n\nimport typer\nfrom buzz import DoExceptParams\nfrom loguru import logger\nfrom typerdrive import TyperdriveError, handle_errors, strip_rich_style, terminal_message\n\n\nclass CallIt(StrEnum):\n    heads = auto()\n    tails = auto()\n\n\ndef log_error(params: DoExceptParams):\n    logger.error(\n        \"\\n\".join(\n            [\n                strip_rich_style(params.final_message),\n                \"--------\",\n                \"Traceback:\",\n                \"\".join(traceback.format_tb(params.trace)),\n            ]\n        )\n    )\n\n\ndef log_success():\n    logger.info(\"No errors occurred!\")\n\n\ndef log_done():\n    logger.info(\"Program complete. Exiting.\")\n\n\ncli = typer.Typer()\n\n\n@cli.command()\n@handle_errors(\n    \"Flip error\",\n    do_except=log_error,\n    do_else=log_success,\n    do_finally=log_done,\n)\ndef flip(call_it: CallIt, show_logs: bool = False):\n    logger.disable(__name__)\n    if show_logs:\n        logger.enable(__name__)\n        logger.info(\"Logging enabled\")\n    result = random.choice([c for c in CallIt])\n    logger.debug(f\"Result: {result}\")\n    if call_it != result:\n        raise TyperdriveError(\n            f\"[yellow]{result}[/yellow], [red]you lose![/red]\",\n            subject=\"Womp, womp\",\n            footer=\"Don't sweat it; just try again!\",\n        )\n    terminal_message(\n        f\"[yellow]{result}[/yellow], [green]you win![/green]\",\n        subject=\"Tada!\",\n        footer=\"Maybe you won't be so lucky next time!\",\n    )\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>This example command simulates a coin flip where an exception is raised any time the outcome of the coin flip doesn't match the user's guess. This provides a nice way to see how the error handling works with a single command.</p> <p>Let's try it out:</p> <pre><code>$ python examples/exceptions/handle_errors.py tails\n\n\u256d\u2500 Tada! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   tails, you win!                                                            \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Maybe you won't be so lucky next time! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Ok, so on my first try, I guessed correctly, and a message was displayed for to tell me I won.</p> <p>Great, let's try again and see what happens:</p> <pre><code>$ python examples/exceptions/handle_errors.py tails\n\n\u256d\u2500 Womp, womp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   heads, you lose!                                                           \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Don't sweat it; just try again! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>So this time I lost, and again a message is showt to let me know. However, this time the function doesn't explicitly print the message. Instead, it raises a <code>TyperdriveError</code> which is handled by the <code>@handle_errors()</code> decorator instead.</p> <p>No stack trace is shown to the user and the message that is displayed has none of the trappings of an exception message. Instead, it's clear and simple so the user will understand what is going on.</p> <p>The great power of this error handling is that a <code>TyperdriveError</code> that is raised in any code that is called by the command function will also be caught and presented nicely to the user.</p> <p>Next, let's try the command with the <code>--show-logs</code> option that is available:</p> <pre><code>$ python examples/exceptions/handle_errors.py tails --show-logs\n2025-04-25 17:48:54,680: DEBUG -&gt; Result: tails\n\n\u256d\u2500 Tada! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   tails, you win!                                                            \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Maybe you won't be so lucky next time! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n2025-04-25 17:48:54,682: INFO -&gt; No errors occurred!\n2025-04-25 17:48:54,682: INFO -&gt; Program complete. Exiting.\n</code></pre> <p>I won again this time, but this time I get to see the app's logs. Notice that in the function body, there is only one logging statement to log the result. However, we have passed three parameters to the <code>@handle_errors()</code> decorator that each log some data.</p> <p>Because I won, only the functions provided with the  <code>do_else</code> and <code>do_finally</code> options are actually called. Both of these functions take no parameters and simply log a message. Regardless of whether an exception was raised or not, any provided <code>do_finally</code> function will be called after the command function returns. The <code>do_else</code> option will only be triggered if no exceptions were raised in the function body.</p> <p>Let's try another flip:</p> <pre><code>$ python examples/exceptions/handle_errors.py tails --show-logs\n2025-04-25 17:52:37,977: DEBUG -&gt; Result: heads\n2025-04-25 17:52:37,978: ERROR -&gt; Flip error -- TyperdriveError: heads, you lose!\n--------\nTraceback:\n  File \"/home/dusktreader/git-repos/personal/typerdrive/src/typerdrive/exceptions.py\", line 69, in wrapper\n    return_value = func(*args, **kwargs)\n  File \"/home/dusktreader/git-repos/personal/typerdrive/examples/exceptions/handle_errors.py\", line 62, in flip\n    raise TyperdriveError(\n    ...&lt;3 lines&gt;...\n    )\n\n\n\u256d\u2500 Womp, womp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   heads, you lose!                                                           \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Don't sweat it; just try again! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n2025-04-25 17:52:37,980: INFO -&gt; Program complete. Exiting.\n</code></pre> <p>This time I lost again, and a lot more information was logged. The <code>do_except</code> function is triggered whenever an exception is handled by the <code>@handle_errors()</code> decorator. The function is passed a special argument which is an instance of the <code>DoExceptParams</code> data class provided by the <code>py-buzz</code> package. This argument carries with it some detailed information about the handled error. In this case, our <code>log_error()</code> function uses the stack trace contained in the param to show a traceback of the handled error in the logs.</p> <p>All three of the <code>do_.*</code> parameters are useful, but the <code>do_except</code> parameter is the most powerful because you can do some post-processing on the error any time one is handled.</p> <p>It's worth pointing out here that this example doesn't tell the <code>@handle_errors()</code> decorator what kind of exceptions it should handle. By default, <code>@handle_errors()</code> will only handle instances of <code>TyperdriveError</code> or one of its descendants. If you want to handle a different exception type (or any of its descendants), you can provide it in the <code>handle_exc_class</code> keyword argument. If, for instance, you wanted the handler to catch any and all errors that might be raised in the command function, you could pass <code>handle_exc_class=Exception</code> to the decorator.</p>"},{"location":"features/exceptions/#details","title":"Details","text":"<p>Now, let's dive a little deeper into the details of the <code>@handle_errors()</code> decorator.</p>"},{"location":"features/exceptions/#base_message","title":"<code>base_message</code>","text":"<p>This is the <code>base_message</code> that will be included with the final message that is passed in the <code>DoExceptParams</code> that are passed to the <code>do_except</code> function. This base message can be overridden by setting the <code>subject</code> on a <code>TyperdriveError</code> (or exception class derived from it. When the error message is displayed for the user, the <code>base_message</code> is the text that is used for the \"subject\" (also known as \"title\") of the panel that the exception's message will be displayed inside of. This parameter is required.</p> <p>This parameter is an analog of the <code>base_message</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#handle_exc_class","title":"<code>handle_exc_class</code>","text":"<p>This keyword argument identifies the exception type that will be handled by the <code>@handle_errors()</code> decorator. Any exception that is an instance of this type or an instance of any class that inherits from it will be handled. By default, this kwarg is set to <code>TyperdriveError</code> exception class. It is also possible to provide a <code>tuple</code> of exception types that should be handled by the decorator.</p> <p>This parameter is an analog of the <code>handle_exc_class</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#ignore_exc_class","title":"<code>ignore_exc_class</code>","text":"<p>This kwarg is only useful when combined with <code>handle_exc_class</code>. It identifies an exception type that should not be handled by the <code>@handle_errors()</code> decorator even if it is a subclass of the exception type passed to <code>handle_exc_class</code>. This is useful to selectively omit specific exception types from handling. This is particularly important if you set <code>handle_exc_class=Exception</code> and you still need to let certain exception types escape. Like <code>handle_exc_class</code>, this can be passed a <code>tuple</code> of exception types each of which will be ignored.</p> <p>This parameter is an analog of the <code>ignore_exc_class</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#do_except","title":"<code>do_except</code>","text":"<p>This keyword argument provides a function that will be called anytime an exception is handled by the <code>@handle_errors()</code> decorator. The function provided in this kwarg must take exactly one argument of type <code>DoExceptParams</code>. <code>DoExceptParams</code> is a dataclass that carries specific information about the handled error including:</p> <ul> <li><code>err</code>: The exception itself</li> <li><code>base_message</code>: As described above</li> <li><code>final_message</code>: A formatted string that include the exception name, <code>base_message</code>, and <code>err</code> message.</li> <li><code>trace</code>: A traceback of the error</li> </ul> <p>The <code>do_except</code> kwarg is most useful for providing a function that will log details about the error without overwhelming your user with this information.</p> <p>This parameter is an analog of the <code>do_except</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#do_else","title":"<code>do_else</code>","text":"<p>This kwarg provides a function that will be called only if no (unhandled) exceptions were raised in the command function body. This function can take no arguments. It is not nearly as powerful as the <code>do_except</code> argument, it may be useful to carry out some task that should only happen if no errors were encountered.</p> <p>This parameter is an analog of the <code>do_else</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#do_finally","title":"<code>do_finally</code>","text":"<p>This keyword argument provides a function that will be called no matter what happens in the command function's body. It does not matter if an exception was raised or not, this function will be called after the command function returns. Again, this kwarg is not as powerful as the <code>do_except</code> option. But it can have its uses, especially when you need to do some cleanup after the command completes.</p> <p>This parameter is an analog of the <code>do_finally</code> parameter used in the <code>handle_errors()</code> context manager from <code>py-buzz</code>.</p>"},{"location":"features/exceptions/#unwrap_message","title":"<code>unwrap_message</code>","text":"<p>By default, the <code>@handle_errors()</code> decorator will unwrap the message that is passed to it. That is, it will first dedent the message then join all the lines together. This is useful because a longer message is often passed in the form of a triple-quoted text block that is optimized for viewing the code. However, we don't know how wide the user's monitor will be. Thus, it's better to let <code>rich</code> do the wrapping for us.</p> <p>However, sometimes the error message has a particular structure to it with indents and newlines. This is the case with <code>Pydantic</code> validation errors. In this case, we don't want the message unwrapped to a single line. If you set the <code>unwrap_message</code> kwarg to <code>False</code> the error will be printed as-is.</p>"},{"location":"features/exceptions/#debug","title":"<code>debug</code>","text":"<p>By default, the <code>@handle_errors()</code> decorator will use only the <code>base_message</code> from a <code>TyperdriveError</code> (or any other <code>Buzz</code> exception). The <code>base_message</code> will have additional information if it was produced from a <code>handle_errors()</code> or <code>check_expressions()</code> context manager from <code>py-buzz</code>. The extended <code>message</code> in the exception may contain information that you don't want to show to your end user. If you want the full message to be displayed in the CLI, then set the <code>debug</code> flag to <code>True</code>.</p>"},{"location":"features/logging/","title":"Managed logging with Loguru","text":"<p>Once your CLI has any degree of sophisitcation, you will probably want to include logging. Additionally, it may be important to keep the logging output in a file (in a reasonable location). It is also important to be able to check the logs, and remembering the reasonable location where the log file is locate can be tricky.</p> <p>While the logging from the standard library is fairly good, I find that the <code>loguru</code> logging package is so much nicer to work with. So, I built loguru along with some other nice helpers into <code>typerdrive</code> to let you focus on building out the business logic of your CLI.</p>"},{"location":"features/logging/#overview","title":"Overview","text":"<p>The <code>typerdrive</code> package provides the <code>@attach_logging()</code> decorator to enable logging for the decorated command. It will enable logging for the <code>typerdrive</code> internals and capture the logs in rotated log files. Additionally, if you include the <code>verbose=True</code> flag in the <code>@attach_logging()</code> decorator, then the logs will also be printed to <code>stdout</code>.</p> <p>In addition to the <code>@attach_logging()</code> decorator, <code>typerdrive</code> also includes three commands for viewing, auditing, and clearing your logs.</p>"},{"location":"features/logging/#usage","title":"Usage","text":"<p>Again, let's look at a code example to see how the <code>@attach_client()</code> decorator can be used:</p> <pre><code>import typer\nfrom loguru import logger\nfrom typerdrive import LoggingManager, attach_logging, set_typerdrive_config\nfrom typerdrive.logging.commands import add_logs_subcommand\n\ncli = typer.Typer()\nadd_logs_subcommand(cli)\nset_typerdrive_config(app_name=\"logging-attach-example\")\n\n\n@cli.command()\n@attach_logging(verbose=True)\ndef report(ctx: typer.Context, manager: LoggingManager, clear: bool = False, count: int = 10):  # pyright: ignore[reportUnusedParameter]\n    logger.info(\"Starting report\")\n    for i in range(count):\n        logger.info(f\"Logging message {i + 1}\")\n    logger.info(\"Completing report\")\n\n    logger.info(\"Showing log\")\n    manager.show()\n\n    logger.info(\"Auditing log directory\")\n    manager.audit()\n\n    if clear:\n        logger.info(\"Clearing the log directory\")\n        manager.clear()\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>In this example, we are simply looping some number of times and logging in each iteration. Once the loop is finished, you will be shown the log file in a pager and, after you close that, a view of the contents of the log directory. The final output from the function will look like this:</p> <pre><code>$ python examples/logging/attach.py report\n15:55:39 | DEBUG | Logging attached to typer context\n15:55:39 | INFO | Starting report\n15:55:39 | INFO | Logging message 1\n15:55:39 | INFO | Logging message 2\n15:55:39 | INFO | Logging message 3\n15:55:39 | INFO | Logging message 4\n15:55:39 | INFO | Logging message 5\n15:55:39 | INFO | Logging message 6\n15:55:39 | INFO | Logging message 7\n15:55:39 | INFO | Logging message 8\n15:55:39 | INFO | Logging message 9\n15:55:39 | INFO | Logging message 10\n15:55:39 | INFO | Completing report\n15:55:39 | INFO | Showing log\n15:55:42 | INFO | Auditing log directory\n\n\u256d\u2500 Current log files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502 \ud83d\udcc2 /home/dusktreader/.local/share/logging-attach-example/logs                \u2502\n\u2502 \u2514\u2500\u2500 \ud83d\udcc4 app.log (1.2 kB)                                                      \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Storing 1.2 kB in 1 files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"features/logging/#details","title":"Details","text":"<p>Let's take a closer look at the logging functionality available with <code>typerdrive</code>.</p>"},{"location":"features/logging/#logs-sub-commands","title":"<code>logs</code> sub-commands","text":"<p>The <code>logs</code> sub-commands can be enabled in your Typer CLI by calling the <code>add_logs_subcommand()</code>. This will enable the following:</p>"},{"location":"features/logging/#show","title":"<code>show</code>","text":"<p>The <code>show</code> command opens the current log file in a pager for you to peruse. Your system's pager will be used. Usually you can exit the pager by using the \"q\" key.</p>"},{"location":"features/logging/#audit","title":"<code>audit</code>","text":"<p>The <code>audit</code> command shows the current state of the directory where the logs are stored. It will show the entire tree structure of the directory and some information about how much data is being stored and how many files there are.</p>"},{"location":"features/logging/#attach_logging-decorator","title":"<code>@attach_logging()</code> decorator","text":"<p>Logging in <code>typerdrive</code> is enabled for a command function through the use of the <code>@attach_logging()</code> decorator. There is one optional argument available: <code>verbose</code>. If this flag is set, then all log lines of <code>DEBUG</code> and above will also be printed to stdout. This should probably only be used for debugging issues in the application as it could potentially bombard your user with a lot of finished.</p>"},{"location":"features/logging/#configuration","title":"Configuration","text":"<p>By default, the log file will be rotated after one week, and log files older than one month will be deleted. Both of these things are configurable using <code>typerdrive.config.set_typerdrive_config()</code>.</p>"},{"location":"features/logging/#log_file_rotation","title":"<code>log_file_rotation</code>","text":"<p>You can control how the log files are rotated using this key. It accepts the same values as the <code>rotation</code> parameter used by <code>loguru.logger.add()</code>. By default, the files are rotated after one week.</p>"},{"location":"features/logging/#log_file_retention","title":"<code>log_file_retention</code>","text":"<p>You can control how the log files are kept using this key. It accepts the same values as the <code>retention</code> parameter used by <code>loguru.logger.add()</code>. By default, the files are deleted after one month.</p>"},{"location":"features/logging/#log_file_compression","title":"<code>log_file_compression</code>","text":"<p>You can control how the log files are compressed upon rotation using this key. It accepts the same values as the <code>compression</code> parameter used by <code>loguru.logger.add()</code>. By default, the files are compressed to <code>tar.gz</code> files.</p>"},{"location":"features/logging/#log_file_name","title":"<code>log_file_name</code>","text":"<p>You can control the name of th log file using this key. By default, it will use \"app.log\".</p>"},{"location":"features/settings/","title":"Commands to manage application settings","text":"<p>Typical applications built with <code>Typer</code> are essentially stateless. That is, to control their behavior, you need to provide all of the configuration for the app through the use of positional arguments, options, and environment variables.</p> <p>For a complex application with many commands, this can be frustrating and slow. You find yourself passing the same parameters over and over.</p> <p>Thus, <code>typerdrive</code> provides a <code>settings</code> subcommand to help with this.</p>"},{"location":"features/settings/#overview","title":"Overview","text":"<p>The <code>typerdrive</code> package provides functionality to store, reuse, and update application settings through a set of subcommands. These subcommands are bound to your app under the <code>settings</code> subcommand. These subcommands manipulate the your app's settings and allow your other commands to access the settings values via the <code>@attach_settings</code> decorator.</p> <p>Let's take a look at how we can use this powerful feature set.</p>"},{"location":"features/settings/#usage","title":"Usage","text":"<p>Let's start by looking at a code example:</p> <pre><code>from typing import Annotated\n\nimport typer\nfrom pydantic import AfterValidator, BaseModel\nfrom snick import unwrap\nfrom typerdrive import add_settings_subcommand, attach_settings, set_typerdrive_config\n\n\ndef valid_alignment(value: str) -&gt; str:\n    if value not in [\"good\", \"neutral\", \"evil\"]:\n        raise ValueError(f\"{value} is an invalid alignment\")\n    return value\n\n\nclass SettingsModel(BaseModel):\n    name: str\n    planet: str\n    is_humanoid: bool = True\n    alignment: Annotated[str, AfterValidator(valid_alignment)] = \"neutral\"\n\n\ncli = typer.Typer()\nadd_settings_subcommand(cli, SettingsModel)\nset_typerdrive_config(app_name=\"settings-commands-example\")\n\n\n@cli.command()\n@attach_settings(SettingsModel)\ndef report(ctx: typer.Context, cfg: SettingsModel):\n    print(\n        unwrap(\n            f\"\"\"\n            Look at this {cfg.alignment} {cfg.name} from {cfg.planet}\n            {\"walking\" if cfg.is_humanoid else \"slithering\"} by.\n            \"\"\"\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>In this example, the app provides a Pydantic model that describes all of the settings values that the app needs. Then, the app calls the <code>add_settings_subcommand()</code> to add the <code>settings</code> feature to the CLI. That's all you need to utilize the <code>settings</code> feature in your app. Now, you can access and manage your settings through the various <code>settings</code> subcommands.</p> <p>In the <code>report</code> command, you can see how the settings values may be accessed within one of the app's other commands. The <code>@attach_settings</code> decorator adds the settings object to the app's <code>typer.Context</code>. Then, the settings can be accessed by providing a parameter to the command that matches the <code>SettingsModel</code> type. The argument that will get the settings object can be named anything you like!</p> <p>Settings model type agreement</p> <p>The type of the pydantic model passed to <code>@attach_settings()</code> MUST match the type used for the settings parameter of the command function. If the types do not match, a <code>Typer</code> exception will be raised saying that Typer doesn't know how to handle the argument.</p> <p>Great, now let's try a few commands in this app to see how the settings commands work.</p> <p>First, we will just show the config</p> <pre><code>$ python examples/settings/commands.py settings show\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                             \u2502\n\u2502   is-humanoid -&gt; True                                                                       \u2502\n\u2502     alignment -&gt; neutral                                                                    \u2502\n\u2502                                                                                             \u2502\n\u2502   Configuration is invalid:                                                                 \u2502\n\u2502          name -&gt; Field required                                                             \u2502\n\u2502        planet -&gt; Field required                                                             \u2502\n\u2502                                                                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As you can see, our settings initially just matches the defaults provided in the settings model.  The fields that still need to be defined are clearly identified and the settings are shown to be invalid.</p> <p>Next, let's make the settings valid by setting the missing values with <code>bind</code>:</p> <pre><code>\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                             \u2502\n\u2502          name -&gt; jawa                                                                       \u2502\n\u2502        planet -&gt; tatooine                                                                   \u2502\n\u2502   is-humanoid -&gt; True                                                                       \u2502\n\u2502     alignment -&gt; neutral                                                                    \u2502\n\u2502                                                                                             \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/commands.py/settings.json \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Now, the settings are valid. You can also see that the settings were saved to disk for your app to use in future commands.</p> <p>Let's make an adjustment to the settings using the <code>update</code> command:</p> <pre><code>$ python examples/settings/commands.py settings update --name=hutt --no-is-humanoid\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                             \u2502\n\u2502          name -&gt; hutt                                                                       \u2502\n\u2502        planet -&gt; tatooine                                                                   \u2502\n\u2502   is-humanoid -&gt; False                                                                      \u2502\n\u2502     alignment -&gt; neutral                                                                    \u2502\n\u2502                                                                                             \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/commands.py/settings.json \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Notice that the <code>update</code> command only changed the values specified and left the others alone.</p> <p>Now that we're happy with our settings, lets run our <code>report</code> command to try out using these app settings:</p> <pre><code>$ python examples/settings/commands.py report\nLook at this neutral hutt from tatooine slithering by.\n</code></pre> <p>Great! Our app is able to use the settings in any command!</p> <p>Finally, let's clear out the settings with <code>reset</code>:</p> <pre><code>\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                             \u2502\n\u2502   is-humanoid -&gt; True                                                                       \u2502\n\u2502     alignment -&gt; neutral                                                                    \u2502\n\u2502                                                                                             \u2502\n\u2502   Configuration is invalid:                                                                 \u2502\n\u2502          name -&gt; Field required                                                             \u2502\n\u2502        planet -&gt; Field required                                                             \u2502\n\u2502                                                                                             \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/commands.py/settings.json \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Now, all the settings are returned to their initial values. Those that have no default values are now invalid.</p>"},{"location":"features/settings/#details","title":"Details","text":"<p>Let's take a closer look at details of each <code>settings</code> subcommand.</p>"},{"location":"features/settings/#bind","title":"<code>bind</code>","text":"<p>The <code>bind</code> command is used to set all your app settings at once. It is very similar to the <code>update</code> command with a few key differences. First, the <code>bind</code> command will not allow you to have an invalid configuration when it is done. It will require each settings value without a default to be explicitly set. After you have provided the values through command options, the final configuration will be validated before it is saved.</p> <p>Like the other <code>settings</code> subcommands that modify the settings, <code>bind</code> will write a settings file to disk when it is finished. The settings file is stored in <code>~/.local/share/&lt;your-app-name&gt;/settings.json</code>. If the parent directories for this file don't exist, they will be created.</p> <p>Not supported on Windows</p> <p>Currently, the <code>typerdrive</code> <code>settings</code> commands are only configured to work on Linux and MacOS. I have plans to add support for Windows as well eventually, but at the moment <code>typerdrive</code> is dependent on settings being stored below <code>~/.local/share</code></p> <p>Each settings value from the settings model you provide is mapped to a CLI option for the <code>bind</code> subcommand. If the value has a default in the model, then the option will use the same default. Boolean values use the normal convention from Typer with <code>--flag</code> or <code>--no-flag</code> controlling the value of the boolean.</p> <p>The help text from our example above for the <code>bind</code> subcommand looks like this:</p> <pre><code>$ python examples/settings/commands.py settings bind --help\n\n Usage: commands.py settings bind [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --name                               TEXT  [default: None] [required]                   \u2502\n\u2502 *  --planet                             TEXT  [default: None] [required]                   \u2502\n\u2502    --is-humanoid    --no-is-humanoid          [default: is-humanoid]                       \u2502\n\u2502    --alignment                          TEXT  [default: neutral]                           \u2502\n\u2502    --help                                     Show this message and exit.                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"features/settings/#update","title":"<code>update</code>","text":"<p>The <code>update</code> command is used to update a subset of the available settings values. It works very similarly to the <code>bind</code> command, however, the <code>update</code> command will allow your configuration to be invalid when it is finished. This might be useful if you want to establish some values in your settings now but need to look something up before you are finished configuring the app.</p> <p>Like the other subcommands that modify settings, <code>update</code> will save all changes to disk.</p> <p>Each settings value from the settings model is mapped to an optional CLI option for the <code>update</code> subcommand. If the settings value is a boolean, it will use the <code>--flag</code> / <code>--no-flag</code> format. All other commands will default to <code>None</code> if they are not passed and the <code>update</code> command will ignore them.</p> <p>The help text from our example above for the <code>update</code> subcommand looks like this:</p> <pre><code>$ python examples/settings/commands.py settings update --help\n\n Usage: commands.py settings update [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --name                               TEXT  [default: None]                                                                                                                                                                                                                              \u2502\n\u2502 --planet                             TEXT  [default: None]                                                                                                                                                                                                                              \u2502\n\u2502 --is-humanoid    --no-is-humanoid          [default: is-humanoid]                                                                                                                                                                                                                       \u2502\n\u2502 --alignment                          TEXT  [default: None]                                                                                                                                                                                                                              \u2502\n\u2502 --help                                     Show this message and exit.                                                                                                                                                                                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Notice how now all the options have a default.</p>"},{"location":"features/settings/#unset","title":"<code>unset</code>","text":"<p>The <code>unset</code> command is used to return a settings value to its initial state. If the value has a default, it will be set to that value. If it does not have a default, it will simply be removed. Like the <code>update</code> subcommand, <code>unset</code> allows the settings to be in invalid state.</p> <p>Each settings value from the settings model is mapped to a CLI option that <code>takes no value</code>. If you supply the option, then the corresponding setting value will be unset.</p> <p>The help text from our example above for the <code>unset</code> subcommand looks like this:</p> <pre><code>$ python examples/settings/commands.py settings unset --help\n\n Usage: commands.py settings unset [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --name                                                                                                                                                                                                                                                                                  \u2502\n\u2502 --planet                                                                                                                                                                                                                                                                                \u2502\n\u2502 --is-humanoid                                                                                                                                                                                                                                                                           \u2502\n\u2502 --alignment                                                                                                                                                                                                                                                                             \u2502\n\u2502 --help                 Show this message and exit.                                                                                                                                                                                                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"features/settings/#show","title":"<code>show</code>","text":"<p>The <code>show</code> command just shows the current value of the settings. That's it!</p>"},{"location":"features/settings/#reset","title":"<code>reset</code>","text":"<p>The <code>reset</code> command returns all settings values to their initial state. It allows the settings to be in an invalid state when it is finished. It will also show the new settings values when it is done. The <code>reset</code> subcommand takes no arguments.</p>"},{"location":"features/settings/#nested-settings-models","title":"Nested settings models","text":"<p>It is possible to have your settings model include nested pydantic models for the settings values. If the settings model has nested models, the arguments to <code>bind</code> and <code>update</code> should be JSON strings.</p> <p>Consider this example:</p> <pre><code>from typing import Annotated\n\nimport typer\nfrom pydantic import AfterValidator, BaseModel\nfrom snick import unwrap\nfrom typerdrive import add_settings_subcommand, attach_settings, set_typerdrive_config\n\n\ndef valid_alignment(value: str) -&gt; str:\n    if value not in [\"good\", \"neutral\", \"evil\"]:\n        raise ValueError(f\"{value} is an invalid alignment\")\n    return value\n\n\nclass ColorModel(BaseModel):\n    eyes: str\n    hair: str\n\n\nclass SettingsModel(BaseModel):\n    name: str\n    planet: str\n    coloration: ColorModel\n    is_humanoid: bool = True\n    alignment: Annotated[str, AfterValidator(valid_alignment)] = \"neutral\"\n\n\ncli = typer.Typer()\nadd_settings_subcommand(cli, SettingsModel)\nset_typerdrive_config(app_name=\"settings-nested-example\")\n\n\n@cli.command()\n@attach_settings(SettingsModel)\ndef report(ctx: typer.Context, cfg: SettingsModel):\n    print(\n        unwrap(\n            f\"\"\"\n            Look at this {cfg.alignment} {cfg.name} from {cfg.planet}\n            with {cfg.coloration.eyes} eyes and {cfg.coloration.hair} hair\n            {\"walking\" if cfg.is_humanoid else \"slithering\"} by.\n            \"\"\"\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>With such a settings configuration, you would bind your settings with a command like:</p> <pre><code>$ python examples/settings/nested.py settings bind --name=jawa --planet=tatooine --coloration='{\"eyes\": \"yellow\", \"hair\": \"black\"}'\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                            \u2502\n\u2502          name -&gt; jawa                                                                      \u2502\n\u2502        planet -&gt; tatooine                                                                  \u2502\n\u2502    coloration -&gt; eyes='yellow' hair='black'                                                \u2502\n\u2502   is-humanoid -&gt; True                                                                      \u2502\n\u2502     alignment -&gt; neutral                                                                   \u2502\n\u2502                                                                                            \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/settings-nested-example/settings.json \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"features/settings/#the-get_settings-functions","title":"The <code>get_settings()</code> functions","text":"<p>In order for <code>typerdrive</code> to provide the settings through an argument to the command function, we have to tap into a bit of Python and Typer's \"mystical energy field\". If you want to use something more direct, you can access the settings object using the <code>get_settings()</code> function to extract it from the <code>typer.Context</code> instead. Rewriting the <code>report()</code> command to use the <code>get_settings()</code> function would look like this:</p> <pre><code>@cli.command()\n@attach_settings(SettingsModel)\ndef report(ctx: typer.Context):\n    cfg = get_settings(ctx, SettingsModel)\n    print(\n        unwrap(\n            f\"\"\"\n            Look at this {cfg.alignment} {cfg.name} from {cfg.planet}\n            {'walking' if cfg.is_humanoid else 'slithering'} by.\n            \"\"\"\n        )\n    )\n</code></pre> <p>The <code>type_hint</code> argument to <code>get_settings()</code></p> <p>Because the model is bound to the settings commands dynamically, the <code>get_settings()</code> function needs a type hint to cast it to the appropriate model type. This <code>type_hint</code> argument must match with the settings model that was attached or an exception will be raised.</p>"},{"location":"features/settings/#the-add_-functions","title":"The <code>add_.*()</code> functions","text":"<p>The <code>typerdrive.settings.commands</code> module has several <code>add_.*()</code> functions. These work by adding a subcommand to the CLI app that is passed in. In general, you only need to use the <code>add_settings_subcommand()</code> in your app. However, if you want to customize where the settings subcommands appear, you may call the other <code>add_.*()</code> functions directly</p>"},{"location":"features/settings/#add_bind","title":"<code>add_bind()</code>","text":"<p>This method adds the <code>bind</code> subcommand to the provided CLI app. It uses the <code>build_command()</code> function to dynamically create a command and then adds it to the <code>cli</code> argument.</p> <p>Function Reference</p>"},{"location":"features/settings/#add_update","title":"<code>add_update()</code>","text":"<p>This method adds the <code>update</code> subcommand to the provided CLI app. It uses the <code>build_command()</code> function to dynamically create a command and then adds it to the <code>cli</code> argument.</p> <p>Function Reference</p>"},{"location":"features/settings/#add_unset","title":"<code>add_unset()</code>","text":"<p>This method adds the <code>unset</code> subcommand to the provided CLI app. It uses the <code>build_command()</code> function to dynamically create a command and then adds it to the <code>cli</code> argument.</p> <p>Function Reference</p>"},{"location":"features/settings/#add_show","title":"<code>add_show()</code>","text":"<p>This method adds the <code>show</code> subcommand to the provided CLI app. It uses the <code>build_command()</code> function to dynamically create a command and then adds it to the <code>cli</code> argument.</p> <p>Function Reference</p>"},{"location":"features/settings/#add_reset","title":"<code>add_reset()</code>","text":"<p>This method adds the <code>reset</code> subcommand to the provided CLI app. It uses the <code>build_command()</code> function to dynamically create a command and then adds it to the <code>cli</code> argument.</p> <p>Function Reference</p>"},{"location":"features/settings/#add_settings_subcommand","title":"<code>add_settings_subcommand()</code>","text":"<p>This method does three things:</p> <ul> <li>Creates a new Typer app</li> <li>Adds all the settings subcommands to the new app</li> <li>Adds the new app as a subcommand of the Typer CLI that you provide</li> </ul> <p>The result is that all the subcommands are available under one <code>settings</code> subcommand.</p> <p>Function Reference</p>"},{"location":"reference/base_modules/","title":"typerdrive Base Modules","text":""},{"location":"reference/base_modules/#typerdrive.config","title":"typerdrive.config","text":"<p>Provide controls for the configuration of <code>typerdrive</code> itself.</p> Note <p>This is distinct from the functionality provided in the <code>settings</code> module. The <code>settings</code> feature is for configuring the app built with <code>typerdrive</code>. Usually, settings reflect behavior specific to the app. The <code>config</code> feature is for configuring <code>typerdrive</code> internal behavior. The <code>config</code> features should never be exposed to end-users or used to manage behavior of the app built on top of <code>typerdrive</code>.</p>"},{"location":"reference/base_modules/#typerdrive.config-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.config-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig","title":"TyperdriveConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Define the configurable attributes of <code>typerdrive</code>.</p> Source code in <code>src/typerdrive/config.py</code> <pre><code>class TyperdriveConfig(BaseModel):\n    \"\"\"\n    Define the configurable attributes of `typerdrive`.\n    \"\"\"\n\n    app_name: str = sys.argv[0].split(\"/\")[-1]\n    \"\"\"\n    The name of the app built on `typerdrive`. Use this setting if you want to override the default behavior of using\n    `sys.argv[0]`.\n    \"\"\"\n\n    log_file_rotation: FileRotationSpec = \"1 week\"\n    \"\"\"\n    Define the how often logs should be rotated. See the\n    [`loguru` docs](https://loguru.readthedocs.io/en/stable/overview.html#easier-file-logging-with-rotation-retention-compression)\n    for more information.\n    \"\"\"\n\n    log_file_retention: FileRetentionSpec = \"1 month\"\n    \"\"\"\n    Define the how soon logs should be deleted. See the\n    [`loguru` docs](https://loguru.readthedocs.io/en/stable/overview.html#easier-file-logging-with-rotation-retention-compression)\n    for more information.\n    \"\"\"\n\n    log_file_compression: FileCompressionSpec = \"tar.gz\"\n    \"\"\"\n    Define whether rotated logs should be compressed. See the\n    [`loguru` docs](https://loguru.readthedocs.io/en/stable/overview.html#easier-file-logging-with-rotation-retention-compression)\n    for more information.\n    \"\"\"\n\n    log_file_name: str = \"app.log\"\n    \"\"\" The name of the file where logs will be written. This file will be created in the `log_dir` directory. \"\"\"\n\n    console_width: int | None = None\n    \"\"\" Set the width of the console for `rich.console`. Will override automatic resizing behavior. \"\"\"\n\n    console_ascii_only: bool = False\n    \"\"\" If set, only use ascii characters in the console. \"\"\"\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def log_dir(self) -&gt; Path:\n        \"\"\"\n        Retrieve the directory where logs will be stored.\n        \"\"\"\n        return Path.home() / \".local/share\" / self.app_name / \"logs\"\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def settings_path(self) -&gt; Path:\n        \"\"\"\n        Retrieve the file where settings will be stored.\n        \"\"\"\n        return Path.home() / \".local/share\" / self.app_name / \"settings.json\"\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def cache_dir(self) -&gt; Path:\n        \"\"\"\n        Retrieve the directory where the cache data will be stored.\n        \"\"\"\n        return Path.home() / \".cache\" / self.app_name\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.app_name","title":"app_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_name: str = split('/')[-1]\n</code></pre> <p>The name of the app built on <code>typerdrive</code>. Use this setting if you want to override the default behavior of using <code>sys.argv[0]</code>.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.cache_dir","title":"cache_dir  <code>property</code>","text":"<pre><code>cache_dir: Path\n</code></pre> <p>Retrieve the directory where the cache data will be stored.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.console_ascii_only","title":"console_ascii_only  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console_ascii_only: bool = False\n</code></pre> <p>If set, only use ascii characters in the console.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.console_width","title":"console_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console_width: int | None = None\n</code></pre> <p>Set the width of the console for <code>rich.console</code>. Will override automatic resizing behavior.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.log_dir","title":"log_dir  <code>property</code>","text":"<pre><code>log_dir: Path\n</code></pre> <p>Retrieve the directory where logs will be stored.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.log_file_compression","title":"log_file_compression  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_file_compression: FileCompressionSpec = 'tar.gz'\n</code></pre> <p>Define whether rotated logs should be compressed. See the <code>loguru</code> docs for more information.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.log_file_name","title":"log_file_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_file_name: str = 'app.log'\n</code></pre> <p>The name of the file where logs will be written. This file will be created in the <code>log_dir</code> directory.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.log_file_retention","title":"log_file_retention  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_file_retention: FileRetentionSpec = '1 month'\n</code></pre> <p>Define the how soon logs should be deleted. See the <code>loguru</code> docs for more information.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.log_file_rotation","title":"log_file_rotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_file_rotation: FileRotationSpec = '1 week'\n</code></pre> <p>Define the how often logs should be rotated. See the <code>loguru</code> docs for more information.</p>"},{"location":"reference/base_modules/#typerdrive.config.TyperdriveConfig.settings_path","title":"settings_path  <code>property</code>","text":"<pre><code>settings_path: Path\n</code></pre> <p>Retrieve the file where settings will be stored.</p>"},{"location":"reference/base_modules/#typerdrive.config-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.config.get_typerdrive_config","title":"get_typerdrive_config","text":"<pre><code>get_typerdrive_config() -&gt; TyperdriveConfig\n</code></pre> <p>Retrieve the current <code>TyperdriveConfig</code>.</p> Source code in <code>src/typerdrive/config.py</code> <pre><code>def get_typerdrive_config() -&gt; TyperdriveConfig:\n    \"\"\"\n    Retrieve the current `TyperdriveConfig`.\n    \"\"\"\n    return _typerdrive_config.model_copy()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.config.set_typerdrive_config","title":"set_typerdrive_config","text":"<pre><code>set_typerdrive_config(**kwargs: Any)\n</code></pre> <p>Update the <code>TyperdriveConfig</code> with the provided key/values.</p> Source code in <code>src/typerdrive/config.py</code> <pre><code>def set_typerdrive_config(**kwargs: Any):\n    \"\"\"\n    Update the `TyperdriveConfig` with the provided key/values.\n    \"\"\"\n    global _typerdrive_config\n    combined_config = {**_typerdrive_config.model_dump(), **kwargs}\n\n    # TyperdriveConfigError?\n    with TyperdriveError.handle_errors(\"Invalid typerdrive config provided\"):\n        _typerdrive_config = TyperdriveConfig(**combined_config)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants","title":"typerdrive.constants","text":"<p>Provide some constants for the project.</p>"},{"location":"reference/base_modules/#typerdrive.constants-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.constants.ExitCode","title":"ExitCode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Maps exit codes for the application.</p> Source code in <code>src/typerdrive/constants.py</code> <pre><code>class ExitCode(IntEnum):\n    \"\"\"\n    Maps exit codes for the application.\n    \"\"\"\n\n    SUCCESS = 0\n    GENERAL_ERROR = 1\n    CANNOT_EXECUTE = 126\n    INTERNAL_ERROR = 128\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.ExitCode-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.constants.ExitCode.CANNOT_EXECUTE","title":"CANNOT_EXECUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANNOT_EXECUTE = 126\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.ExitCode.GENERAL_ERROR","title":"GENERAL_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAL_ERROR = 1\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.ExitCode.INTERNAL_ERROR","title":"INTERNAL_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERNAL_ERROR = 128\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.ExitCode.SUCCESS","title":"SUCCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUCCESS = 0\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.Validation","title":"Validation","text":"<p>               Bases: <code>Flag</code></p> <p>Defines when validation of settings should happen in the <code>@attach_settings</code> context manager.</p> Source code in <code>src/typerdrive/constants.py</code> <pre><code>class Validation(Flag):\n    \"\"\"\n    Defines when validation of settings should happen in the `@attach_settings` context manager.\n    \"\"\"\n\n    BEFORE = auto()\n    AFTER = auto()\n    BOTH = BEFORE | AFTER\n    NEVER = 0\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.Validation-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.constants.Validation.AFTER","title":"AFTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AFTER = auto()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.Validation.BEFORE","title":"BEFORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BEFORE = auto()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.Validation.BOTH","title":"BOTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTH = BEFORE | AFTER\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.constants.Validation.NEVER","title":"NEVER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEVER = 0\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context","title":"typerdrive.context","text":"<p>Provide tools for working with the <code>TyperContext</code> and the <code>TyperdriveContext</code>.</p>"},{"location":"reference/base_modules/#typerdrive.context-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext","title":"TyperdriveContext  <code>dataclass</code>","text":"<p>Define the <code>typerdrive</code> context that is attached to the <code>Typer.Context</code> as <code>obj</code>.</p> Source code in <code>src/typerdrive/context.py</code> <pre><code>@dataclass\nclass TyperdriveContext:\n    \"\"\"\n    Define the `typerdrive` context that is attached to the `Typer.Context` as `obj`.\n    \"\"\"\n    settings_manager: SettingsManager | None = None\n    cache_manager: CacheManager | None = None\n    client_manager: ClientManager | None = None\n    logging_manager: LoggingManager | None = None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext.cache_manager","title":"cache_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache_manager: CacheManager | None = None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext.client_manager","title":"client_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_manager: ClientManager | None = None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext.logging_manager","title":"logging_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging_manager: LoggingManager | None = None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext.settings_manager","title":"settings_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>settings_manager: SettingsManager | None = None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.context.TyperdriveContext.__init__","title":"__init__","text":"<pre><code>__init__(\n    settings_manager: SettingsManager | None = None,\n    cache_manager: CacheManager | None = None,\n    client_manager: ClientManager | None = None,\n    logging_manager: LoggingManager | None = None,\n) -&gt; None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.context.from_context","title":"from_context","text":"<pre><code>from_context(ctx: Context, name: str) -&gt; TyperdriveManager\n</code></pre> <p>Retrieve a <code>TyperdriveManager</code> from the <code>TyperdriveContext</code> at the given <code>name</code>.</p> Source code in <code>src/typerdrive/context.py</code> <pre><code>def from_context(ctx: typer.Context, name: str) -&gt; TyperdriveManager:\n    \"\"\"\n    Retrieve a `TyperdriveManager` from the `TyperdriveContext` at the given `name`.\n    \"\"\"\n    user_context = get_user_context(ctx)\n    return ContextError.enforce_defined(getattr(user_context, name), f\"{name} is not bound to context\")\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.get_user_context","title":"get_user_context","text":"<pre><code>get_user_context(ctx: Context)\n</code></pre> <p>Retrieve the user context from the <code>typer.Context</code>.</p> <p>If a user context has not been established yet, it will be initialized.</p> <p>Read the 'click' docs to learn more.</p> Source code in <code>src/typerdrive/context.py</code> <pre><code>def get_user_context(ctx: typer.Context):\n    \"\"\"\n    Retrieve the user context from the `typer.Context`.\n\n    If a user context has not been established yet, it will be initialized.\n\n    Read the ['click' docs](https://click.palletsprojects.com/en/stable/complex/#contexts) to learn more.\n    \"\"\"\n    if not ctx.obj:\n        ctx.obj = TyperdriveContext()\n    return ctx.obj\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.context.to_context","title":"to_context","text":"<pre><code>to_context(\n    ctx: Context, name: str, val: TyperdriveManager\n) -&gt; None\n</code></pre> <p>Attach a <code>TyperdriveManager</code> object to the <code>TyperdriveContext</code> at the given <code>name</code>.</p> Source code in <code>src/typerdrive/context.py</code> <pre><code>def to_context(ctx: typer.Context, name: str, val: TyperdriveManager) -&gt; None:\n    \"\"\"\n    Attach a `TyperdriveManager` object to the `TyperdriveContext` at the given `name`.\n    \"\"\"\n    user_context = get_user_context(ctx)\n    field_type = TyperdriveContext.__dataclass_fields__[name].type\n\n    if get_origin(field_type) is UnionType:\n        defined_types = [t for t in get_args(field_type) if t is not NoneType]\n        require_condition(\n            len(defined_types) == 1,\n            \"PANIC! TyperdriveContext fields must only have one type or None.\",\n            raise_exc_class=RuntimeError,\n        )\n        field_type = defined_types[0]\n\n    # TODO: Get the type hinting on the next line right.\n    ContextError.ensure_type(val, field_type, \"Value is not of type any of the union types\")  # type: ignore[arg-type]\n\n    setattr(user_context, name, val)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs","title":"typerdrive.dirs","text":"<p>Provide methods for working with directories.</p>"},{"location":"reference/base_modules/#typerdrive.dirs-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo","title":"DirInfo  <code>dataclass</code>","text":"<p>Describes directory info needed for the <code>render_directory()</code> function.</p> Source code in <code>src/typerdrive/dirs.py</code> <pre><code>@dataclass\nclass DirInfo:\n    \"\"\"\n    Describes directory info needed for the `render_directory()` function.\n    \"\"\"\n\n    tree: Tree\n    file_count: int\n    total_size: int\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo.file_count","title":"file_count  <code>instance-attribute</code>","text":"<pre><code>file_count: int\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo.total_size","title":"total_size  <code>instance-attribute</code>","text":"<pre><code>total_size: int\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo.tree","title":"tree  <code>instance-attribute</code>","text":"<pre><code>tree: Tree\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.dirs.DirInfo.__init__","title":"__init__","text":"<pre><code>__init__(\n    tree: Tree, file_count: int, total_size: int\n) -&gt; None\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.dirs.clear_directory","title":"clear_directory","text":"<pre><code>clear_directory(path: Path) -&gt; int\n</code></pre> <p>Delete all files and directories in the directory at the given path.</p> <p>If the target path is not a directory, an exception will be raised. If the target path does not exist, an exception will be raised.</p> Source code in <code>src/typerdrive/dirs.py</code> <pre><code>def clear_directory(path: Path) -&gt; int:\n    \"\"\"\n    Delete all files and directories in the directory at the given path.\n\n    If the target path is not a directory, an exception will be raised.\n    If the target path does not exist, an exception will be raised.\n    \"\"\"\n    TyperdriveError.require_condition(path.exists(), f\"Target {path=} does not exist\")\n    TyperdriveError.require_condition(path.is_dir(), f\"Target {path=} is not a directory\")\n    with TyperdriveError.handle_errors(f\"Failed to clear directory at {path=}\"):\n        return _clear_dir(path)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.is_child","title":"is_child","text":"<pre><code>is_child(path: Path, parent: Path) -&gt; bool\n</code></pre> <p>Return true if the given path is a child of the given parent.</p> Source code in <code>src/typerdrive/dirs.py</code> <pre><code>def is_child(path: Path, parent: Path) -&gt; bool:\n    \"\"\"\n    Return true if the given path is a child of the given parent.\n    \"\"\"\n    root_path = Path(path.parts[0])\n    temp_path = path\n    while temp_path != root_path:\n        if temp_path == parent:\n            return True\n        temp_path = temp_path.parent\n    return False\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.render_directory","title":"render_directory","text":"<pre><code>render_directory(\n    path: Path, is_root: bool = True\n) -&gt; DirInfo\n</code></pre> <p>Render a visualization of the directory at the given path using <code>rich.tree</code>.</p> <p>This is a recursive function. If calling this function, you should call it with <code>is_root=True</code>.</p> Source code in <code>src/typerdrive/dirs.py</code> <pre><code>def render_directory(path: Path, is_root: bool = True) -&gt; DirInfo:\n    \"\"\"\n    Render a visualization of the directory at the given path using `rich.tree`.\n\n    This is a recursive function. If calling this function, you should call it with `is_root=True`.\n    \"\"\"\n    root_label: str\n    if is_root:\n        root_label = str(path)\n        color = \"[bold yellow]\"\n    else:\n        root_label = escape(path.name)\n        color = \"[bold blue]\"\n\n    dir_info = DirInfo(\n        tree=Tree(f\"{color}\ud83d\udcc2 {root_label}\"),\n        file_count=0,\n        total_size=0,\n    )\n\n    child_paths = sorted(\n        path.iterdir(),\n        key=lambda p: (\n            p.is_file(),\n            p.name.lower(),\n        ),\n    )\n    for child_path in child_paths:\n        if child_path.is_dir():\n            child_info = render_directory(child_path, is_root=False)\n            dir_info.tree\n            dir_info.tree.children.append(child_info.tree)\n            dir_info.file_count += child_info.file_count\n            dir_info.total_size += child_info.total_size\n        else:\n            file_size = child_path.stat().st_size\n            icon = Text(\"\ud83d\udcc4 \")\n            label = Text(escape(child_path.name), \"green\")\n            info = Text(f\" ({humanize.naturalsize(file_size)})\", \"blue\")\n            dir_info.tree.add(icon + label + info)\n            dir_info.file_count += 1\n            dir_info.total_size += file_size\n    return dir_info\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.dirs.show_directory","title":"show_directory","text":"<pre><code>show_directory(path: Path, subject: str | None = None)\n</code></pre> <p>Print the visualization of a target directory retrieved with <code>render_directory()</code> using <code>terminal_message</code>.</p> Source code in <code>src/typerdrive/dirs.py</code> <pre><code>def show_directory(path: Path, subject: str | None = None):\n    \"\"\"\n    Print the visualization of a target directory retrieved with `render_directory()` using `terminal_message`.\n    \"\"\"\n    dir_info = render_directory(path)\n    human_size = humanize.naturalsize(dir_info.total_size)\n    terminal_message(\n        dir_info.tree,\n        subject=subject or f\"Showing {path}\",\n        footer=f\"Storing {human_size} in {dir_info.file_count} files\",\n    )\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.env","title":"typerdrive.env","text":"<p>Provide utility functions for working with the environment.</p>"},{"location":"reference/base_modules/#typerdrive.env-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.env.tweak_env","title":"tweak_env","text":"<pre><code>tweak_env(**kwargs: str)\n</code></pre> <p>Temporarily alter environment variables for the lifetime of the context manager.</p> <p>All items in <code>kwargs</code> will be set in the environment. If there was exiting value in the given key, it will be restored after the context manager exits. If there was no existing value in the given key, it will have no value after the context manager exits.</p> Source code in <code>src/typerdrive/env.py</code> <pre><code>@contextmanager\ndef tweak_env(**kwargs: str):\n    \"\"\"\n    Temporarily alter environment variables for the lifetime of the context manager.\n\n    All items in `kwargs` will be set in the environment.\n    If there was exiting value in the given key, it will be restored after the context manager exits.\n    If there was no existing value in the given key, it will have no value after the context manager exits.\n    \"\"\"\n    old_vals: dict[str, str] = {}\n    del_vals: list[str] = []\n    for key, val in kwargs.items():\n        old_val = os.environ.get(key, None)\n        if old_val:\n            old_vals[key] = old_val\n        else:\n            del_vals.append(key)\n        os.environ[key] = val\n\n    yield\n\n    for key, val in old_vals.items():\n        os.environ[key] = val\n    for key in del_vals:\n        del os.environ[key]\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions","title":"typerdrive.exceptions","text":"<p>Provide exception types for <code>typerdrive</code>.</p> <p>All exception types derived from <code>TyperdriveError</code> will, by default, be handled by the <code>@handle_errors</code> decorator.</p>"},{"location":"reference/base_modules/#typerdrive.exceptions-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.exceptions.BuildCommandError","title":"BuildCommandError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>Indicates that there was a problem building a command with <code>typer-repyt</code>.</p> Source code in <code>src/typerdrive/exceptions.py</code> <pre><code>class BuildCommandError(TyperdriveError):\n    \"\"\"\n    Indicates that there was a problem building a command with `typer-repyt`.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.INTERNAL_ERROR\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions.BuildCommandError-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.exceptions.BuildCommandError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = INTERNAL_ERROR\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions.ContextError","title":"ContextError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>Indicates that there was a problem interacting with the <code>Typer.Context</code>.</p> Source code in <code>src/typerdrive/exceptions.py</code> <pre><code>class ContextError(TyperdriveError):\n    \"\"\"\n    Indicates that there was a problem interacting with the `Typer.Context`.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.INTERNAL_ERROR\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions.ContextError-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.exceptions.ContextError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = INTERNAL_ERROR\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError","title":"TyperdriveError","text":"<p>               Bases: <code>Buzz</code></p> <p>Base exception class for all <code>typerdrive</code> errors.</p> <p>Derives from the <code>buzz.Buzz</code> base class. See the <code>py-buzz</code> docs to learn more.</p> Source code in <code>src/typerdrive/exceptions.py</code> <pre><code>class TyperdriveError(Buzz):\n    \"\"\"\n    Base exception class for all `typerdrive` errors.\n\n    Derives from the `buzz.Buzz` base class. See the\n    [`py-buzz` docs](https://dusktreader.github.io/py-buzz/features/#the-buzz-base-class) to learn more.\n    \"\"\"\n\n    subject: str | None = None\n    \"\"\" The subject to show on user-facing messages when this error is handled by `@handle_errors()` \"\"\"\n\n    footer: str | None = None\n    \"\"\" The footer to show on user-facing messages when this error is handled by `@handle_errors()` \"\"\"\n\n    exit_code: ExitCode = ExitCode.GENERAL_ERROR\n    \"\"\" The exit code that should be used after handling the error and terminating the app \"\"\"\n\n    details: Any | None = None\n    \"\"\" Any additional details that should be included in the error as well \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        subject: str | None = None,\n        footer: str | None = None,\n        details: Any | None = None,\n        exit_code: ExitCode | None = None,\n        **kwargs: Any,\n    ):\n        super().__init__(*args, **kwargs)\n        if subject:\n            self.subject = subject\n        if footer:\n            self.footer = footer\n        if details:\n            self.details = details\n        if exit_code:\n            self.exit_code = exit_code\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: Any | None = None\n</code></pre> <p>Any additional details that should be included in the error as well</p>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = GENERAL_ERROR\n</code></pre> <p>The exit code that should be used after handling the error and terminating the app</p>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError.footer","title":"footer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>footer: str | None = None\n</code></pre> <p>The footer to show on user-facing messages when this error is handled by <code>@handle_errors()</code></p>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError.subject","title":"subject  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subject: str | None = None\n</code></pre> <p>The subject to show on user-facing messages when this error is handled by <code>@handle_errors()</code></p>"},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.exceptions.TyperdriveError.__init__","title":"__init__","text":"<pre><code>__init__(\n    *args: Any,\n    subject: str | None = None,\n    footer: str | None = None,\n    details: Any | None = None,\n    exit_code: ExitCode | None = None,\n    **kwargs: Any,\n)\n</code></pre> Source code in <code>src/typerdrive/exceptions.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    subject: str | None = None,\n    footer: str | None = None,\n    details: Any | None = None,\n    exit_code: ExitCode | None = None,\n    **kwargs: Any,\n):\n    super().__init__(*args, **kwargs)\n    if subject:\n        self.subject = subject\n    if footer:\n        self.footer = footer\n    if details:\n        self.details = details\n    if exit_code:\n        self.exit_code = exit_code\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.format","title":"typerdrive.format","text":"<p>Provide methods for formatted output for the user.</p>"},{"location":"reference/base_modules/#typerdrive.format-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.format.simple_message","title":"simple_message","text":"<pre><code>simple_message(\n    message: str,\n    indent: bool = False,\n    markdown: bool = False,\n    error: bool = False,\n    to_clipboard: bool = False,\n)\n</code></pre> <p>Show a simple, non-decorated message to the user.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to show to the user; May not be a <code>rich.RenderableType</code></p> required <code>indent</code> <code>bool</code> <p>If <code>True</code>, indent all lines of the message by 2 spaces</p> <code>False</code> <code>markdown</code> <code>bool</code> <p>If <code>True</code>, render the text with <code>rich.markdown</code></p> <code>False</code> <code>error</code> <code>bool</code> <p>If <code>True</code>, print the output to stderr instead of stdout</p> <code>False</code> <code>to_clipboard</code> <code>bool</code> <p>If <code>True</code>, attempt to copy the output to the user's clipboard</p> <code>False</code> Source code in <code>src/typerdrive/format.py</code> <pre><code>def simple_message(\n    message: str,\n    indent: bool = False,\n    markdown: bool = False,\n    error: bool = False,\n    to_clipboard: bool = False,\n):\n    \"\"\"\n    Show a simple, non-decorated message to the user.\n\n    Parameters:\n        message:      The message to show to the user; May not be a `rich.RenderableType`\n        indent:       If `True`, indent all lines of the message by 2 spaces\n        markdown:     If `True`, render the text with `rich.markdown`\n        error:        If `True`, print the output to stderr instead of stdout\n        to_clipboard: If `True`, attempt to copy the output to the user's clipboard\n    \"\"\"\n    text: str = snick.dedent(message)\n\n    if to_clipboard:\n        _to_clipboard(text)\n\n    if indent:\n        text = snick.indent(text, prefix=\"  \")\n\n    content: str | Markdown = text\n\n    if markdown:\n        content = Markdown(text)\n\n    console = Console(stderr=error)\n    console.print()\n    console.print(content)\n    console.print()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.format.strip_rich_style","title":"strip_rich_style","text":"<pre><code>strip_rich_style(text: str | Text) -&gt; str\n</code></pre> <p>Strip all rich styling (color, emphasis, etc.) from the text.</p> Source code in <code>src/typerdrive/format.py</code> <pre><code>def strip_rich_style(text: str | Text) -&gt; str:\n    \"\"\"\n    Strip all rich styling (color, emphasis, etc.) from the text.\n    \"\"\"\n    if isinstance(text, str):\n        text = Text.from_markup(text)\n    return text.plain\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.format.terminal_message","title":"terminal_message","text":"<pre><code>terminal_message(\n    message: RenderableType,\n    subject: str | None = None,\n    subject_align: Literal[\n        \"left\", \"right\", \"center\"\n    ] = \"left\",\n    subject_color: str = \"green\",\n    footer: str | None = None,\n    footer_align: Literal[\n        \"left\", \"right\", \"center\"\n    ] = \"left\",\n    indent: bool = True,\n    markdown: bool = False,\n    error: bool = False,\n    to_clipboard: bool = False,\n)\n</code></pre> <p>Show a formatted message to the user in a <code>rich</code> Panel.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>RenderableType</code> <p>The message to show to the user. May be a string or any other <code>rich.RenderableType</code></p> required <code>subject</code> <code>str | None</code> <p>An optional heading for the panel to show to the user</p> <code>None</code> <code>subject_align</code> <code>Literal['left', 'right', 'center']</code> <p>The alignment for the <code>subject</code></p> <code>'left'</code> <code>subject_color</code> <code>str</code> <p>The color to render the <code>subject</code> in</p> <code>'green'</code> <code>footer</code> <code>str | None</code> <p>An optional footer to show to the user. If <code>to_clipboard</code> results in a successful copy, this will            include a message indicating that the message was copied to the clipboard.</p> <code>None</code> <code>footer_align</code> <code>Literal['left', 'right', 'center']</code> <p>The alignment for the <code>footer</code></p> <code>'left'</code> <code>indent</code> <code>bool</code> <p>If <code>True</code>, indent all lines of the message by 2 spaces</p> <code>True</code> <code>markdown</code> <code>bool</code> <p>If <code>True</code>, render the text with <code>rich.markdown</code></p> <code>False</code> <code>error</code> <code>bool</code> <p>If <code>True</code>, print the output to stderr instead of stdout</p> <code>False</code> <code>to_clipboard</code> <code>bool</code> <p>If <code>True</code>, attempt to copy the output to the user's clipboard. The text copied to the clipboard            will not include the <code>rich.panel</code> decoration including the header and footer.</p> <code>False</code> Source code in <code>src/typerdrive/format.py</code> <pre><code>def terminal_message(\n    message: RenderableType,\n    subject: str | None = None,\n    subject_align: Literal[\"left\", \"right\", \"center\"] = \"left\",\n    subject_color: str = \"green\",\n    footer: str | None = None,\n    footer_align: Literal[\"left\", \"right\", \"center\"] = \"left\",\n    indent: bool = True,\n    markdown: bool = False,\n    error: bool = False,\n    to_clipboard: bool = False,\n):\n    \"\"\"\n    Show a formatted message to the user in a `rich` Panel.\n\n    Parameters:\n        message:       The message to show to the user. May be a string or any other `rich.RenderableType`\n        subject:       An optional heading for the panel to show to the user\n        subject_align: The alignment for the `subject`\n        subject_color: The color to render the `subject` in\n        footer:        An optional footer to show to the user. If `to_clipboard` results in a successful copy, this will\n                       include a message indicating that the message was copied to the clipboard.\n        footer_align:  The alignment for the `footer`\n        indent:        If `True`, indent all lines of the message by 2 spaces\n        markdown:      If `True`, render the text with `rich.markdown`\n        error:         If `True`, print the output to stderr instead of stdout\n        to_clipboard:  If `True`, attempt to copy the output to the user's clipboard. The text copied to the clipboard\n                       will not include the `rich.panel` decoration including the header and footer.\n    \"\"\"\n    if to_clipboard:\n        if _to_clipboard(message):\n            if not footer:\n                footer = \"Copied to clipboard!\"\n            else:\n                footer = f\"{footer} -- Copied to clipboard!\"\n\n    panel_kwargs: dict[str, Any] = dict(padding=1, title_align=subject_align, subtitle_align=footer_align)\n\n    if subject is not None:\n        panel_kwargs[\"title\"] = f\"[{subject_color}]{subject}\"\n\n    if footer is not None:\n        panel_kwargs[\"subtitle\"] = f\"[dim italic]{footer}[/dim italic]\"\n\n    if isinstance(message, str):\n        message = snick.dedent(message)\n        if indent:\n            message = snick.indent(message, prefix=\"  \")\n        if markdown:\n            message = Markdown(message)\n\n    config = get_typerdrive_config()\n    console_kwargs: dict[str, Any] = dict(stderr=error)\n\n    if config.console_width:\n        console_kwargs[\"width\"] = config.console_width\n\n    if config.console_ascii_only:\n        #console_kwargs[\"force_terminal\"] = False\n        panel_kwargs[\"box\"] = box.ASCII\n\n    console = Console(\n        stderr=error,\n\n    )\n    console.print()\n    console.print(Panel(message, **panel_kwargs))\n    console.print()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.handle_errors","title":"typerdrive.handle_errors","text":"<p>Provide an error handler that can be attached to a command through a decorator.</p>"},{"location":"reference/base_modules/#typerdrive.handle_errors-classes","title":"Classes","text":""},{"location":"reference/base_modules/#typerdrive.handle_errors-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.handle_errors.handle_errors","title":"handle_errors","text":"<pre><code>handle_errors(\n    base_message: str,\n    *,\n    handle_exc_class: type[Exception]\n    | tuple[type[Exception], ...] = TyperdriveError,\n    ignore_exc_class: type[Exception]\n    | tuple[type[Exception], ...]\n    | None = None,\n    do_except: Callable[[DoExceptParams], None]\n    | None = None,\n    do_else: Callable[[], None] | None = None,\n    do_finally: Callable[[], None] | None = None,\n    unwrap_message: bool = True,\n    debug: bool = False,\n) -&gt; Callable[\n    [WrappedFunction[P, T]], WrappedFunction[P, T]\n]\n</code></pre> <p>Handle errors raised by the decorated command function and show a user-friendly message in the terminal.</p> <p>The behavior of this function is very similar to the <code>py-buzz</code> <code>handle_errors()</code> context manager. See the py-buzz docs for more context.</p> <p>Parameters:</p> Name Type Description Default <code>base_message</code> <code>str</code> <p>The \"base\" message to be used for the error. This will be the \"subject\" of the message shown               to the user when an error is handled.</p> required <code>handle_exc_class</code> <code>type[Exception] | tuple[type[Exception], ...]</code> <p>The exception class that will be handled. Exception types that inherit from this will also be               handled as well.</p> <code>TyperdriveError</code> <code>ignore_exc_class</code> <code>type[Exception] | tuple[type[Exception], ...] | None</code> <p>An exception class that will not be handled even if it inherits from the <code>handle_exc_class</code>.</p> <code>None</code> <code>do_except</code> <code>Callable[[DoExceptParams], None] | None</code> <p>A function that will be called if an exception is handled. This is most useful for logging               the details of the error.</p> <code>None</code> <code>do_else</code> <code>Callable[[], None] | None</code> <p>A function that will be called if no exceptions were handled.</p> <code>None</code> <code>do_finally</code> <code>Callable[[], None] | None</code> <p>A function that will always be called, even if an exception was handled.</p> <code>None</code> <code>unwrap_message</code> <code>bool</code> <p>If true, \"unwrap\" the message so that newline characters are removed.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>If true, the message shown in the <code>terminal_message</code> will include the string representation of               the handled error. Not as suitable for end-users, and should only be used for debugging.</p> <code>False</code> Source code in <code>src/typerdrive/handle_errors.py</code> <pre><code>def handle_errors(\n    base_message: str,\n    *,\n    handle_exc_class: type[Exception] | tuple[type[Exception], ...] = TyperdriveError,\n    ignore_exc_class: type[Exception] | tuple[type[Exception], ...] | None = None,\n    do_except: Callable[[DoExceptParams], None] | None = None,\n    do_else: Callable[[], None] | None = None,\n    do_finally: Callable[[], None] | None = None,\n    unwrap_message: bool = True,\n    debug: bool = False,\n) -&gt; Callable[[WrappedFunction[P, T]], WrappedFunction[P, T]]:\n    \"\"\"\n    Handle errors raised by the decorated command function and show a user-friendly message in the terminal.\n\n    The behavior of this function is _very_ similar to the `py-buzz` `handle_errors()` context manager. See the\n    [py-buzz docs](https://dusktreader.github.io/py-buzz/features/#exception-handling-context-manager) for more context.\n\n    Parameters:\n        base_message:     The \"base\" message to be used for the error. This will be the \"subject\" of the message shown\n                          to the user when an error is handled.\n        handle_exc_class: The exception class that will be handled. Exception types that inherit from this will also be\n                          handled as well.\n        ignore_exc_class: An exception class that will _not_ be handled even if it inherits from the `handle_exc_class`.\n        do_except:        A function that will be called if an exception is handled. This is most useful for logging\n                          the details of the error.\n        do_else:          A function that will be called if no exceptions were handled.\n        do_finally:       A function that will always be called, even if an exception was handled.\n        unwrap_message:   If true, \"unwrap\" the message so that newline characters are removed.\n        debug:            If true, the message shown in the `terminal_message` will include the string representation of\n                          the handled error. Not as suitable for end-users, and should only be used for debugging.\n    \"\"\"\n\n    class _DefaultIgnoreException(Exception):\n        \"\"\"\n        Define a special exception class to use for the default ignore behavior.\n\n        Basically, this exception type can't be extracted from this method (easily), and thus could never actually\n        be raised in any other context. This is only created here to preserve the `try/except/except/else/finally`\n        structure.\n        \"\"\"\n\n    ignore_exc_class = _DefaultIgnoreException if ignore_exc_class is None else ignore_exc_class\n\n    def _decorate(func: WrappedFunction[P, T]) -&gt; WrappedFunction[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n            return_value: T | None = None\n            try:\n                return_value = func(*args, **kwargs)\n            except ignore_exc_class:\n                raise\n            except handle_exc_class as err:\n                try:\n                    final_message = reformat_exception(base_message, err)\n                except Exception as msg_err:\n                    raise RuntimeError(f\"Failed while formatting message: {repr(msg_err)}\")\n\n                trace = get_traceback()\n\n                if do_except:\n                    do_except(\n                        DoExceptParams(\n                            err=err,\n                            base_message=base_message,\n                            final_message=final_message,\n                            trace=trace,\n                        )\n                    )\n\n                subject: str | None = base_message\n                footer: str | None = None\n                message: str\n\n                exit_code: int = ExitCode.GENERAL_ERROR\n                if isinstance(err, TyperdriveError):\n                    if err.subject:\n                        subject = err.subject\n                    if err.footer:\n                        footer = err.footer\n                    if debug:\n                        message = err.message\n                    else:\n                        message = err.base_message or err.message\n                    if unwrap_message:\n                        message = snick.unwrap(message)\n                    exit_code = err.exit_code\n                else:\n                    message = str(err)\n\n                terminal_message(\n                    message,\n                    subject=f\"[red]{subject}[/red]\",\n                    footer=footer,\n                    error=True,\n                )\n\n                raise typer.Exit(code=exit_code)\n\n            else:\n                if do_else:\n                    do_else()\n                return return_value\n\n            finally:\n                if do_finally:\n                    do_finally()\n\n        return wrapper\n\n    return _decorate\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.types","title":"typerdrive.types","text":"<p>Provide some useful type definitions for the project.</p> <p>The <code>File*</code> types align with loguru file sink rotation and retention spec. Refer to the Loguru documentation for more information:</p> <ul> <li>loguru type definition</li> <li>loguru logger docs</li> </ul>"},{"location":"reference/base_modules/#typerdrive.types-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.types.FileCompressionSpec","title":"FileCompressionSpec  <code>module-attribute</code>","text":"<pre><code>FileCompressionSpec = str | Callable[[str], None]\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.types.FileRetentionSpec","title":"FileRetentionSpec  <code>module-attribute</code>","text":"<pre><code>FileRetentionSpec = (\n    str | int | timedelta | Callable[[list[str]], None]\n)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.types.FileRotationSpec","title":"FileRotationSpec  <code>module-attribute</code>","text":"<pre><code>FileRotationSpec = (\n    str\n    | int\n    | timedelta\n    | time\n    | Callable[[str, TextIO], bool]\n)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.version","title":"typerdrive.version","text":"<p>Provide methods for getting the project version.</p>"},{"location":"reference/base_modules/#typerdrive.version-attributes","title":"Attributes","text":""},{"location":"reference/base_modules/#typerdrive.version.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = get_version()\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.version-functions","title":"Functions","text":""},{"location":"reference/base_modules/#typerdrive.version.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str\n</code></pre> <p>Try to get version from metadata, then fallback to <code>pyproject.toml</code>, then fallback to \"unknown\".</p> Source code in <code>src/typerdrive/version.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"\n    Try to get version from metadata, then fallback to `pyproject.toml`, then fallback to \"unknown\".\n    \"\"\"\n    try:\n        return get_version_from_metadata()\n    except metadata.PackageNotFoundError:\n        try:\n            return get_version_from_pyproject()\n        except (FileNotFoundError, KeyError):\n            return \"unknown\"\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.version.get_version_from_metadata","title":"get_version_from_metadata","text":"<pre><code>get_version_from_metadata() -&gt; str\n</code></pre> <p>Retrieve version from package metadata.</p> Source code in <code>src/typerdrive/version.py</code> <pre><code>def get_version_from_metadata() -&gt; str:\n    \"\"\"\n    Retrieve version from package metadata.\n    \"\"\"\n    return metadata.version(__package__ or __name__)\n</code></pre>"},{"location":"reference/base_modules/#typerdrive.version.get_version_from_pyproject","title":"get_version_from_pyproject","text":"<pre><code>get_version_from_pyproject() -&gt; str\n</code></pre> <p>Retrieve version from the <code>pyproject.toml</code> file.</p> Source code in <code>src/typerdrive/version.py</code> <pre><code>def get_version_from_pyproject() -&gt; str:\n    \"\"\"\n    Retrieve version from the `pyproject.toml` file.\n    \"\"\"\n    with open(\"pyproject.toml\", \"rb\") as file:\n        return tomllib.load(file)[\"project\"][\"version\"]\n</code></pre>"},{"location":"reference/cache/","title":"typerdrive Cache modules","text":""},{"location":"reference/cache/#typerdrive.cache.attach","title":"typerdrive.cache.attach","text":"<p>Provide a decorator that attaches the <code>typerdrive</code> cache to a <code>typer</code> command function.</p>"},{"location":"reference/cache/#typerdrive.cache.attach-attributes","title":"Attributes","text":""},{"location":"reference/cache/#typerdrive.cache.attach-classes","title":"Classes","text":""},{"location":"reference/cache/#typerdrive.cache.attach-functions","title":"Functions","text":""},{"location":"reference/cache/#typerdrive.cache.attach.attach_cache","title":"attach_cache","text":"<pre><code>attach_cache(\n    show: bool = False,\n) -&gt; Callable[\n    [ContextFunction[P, T]], ContextFunction[P, T]\n]\n</code></pre> <p>Attach the <code>typerdrive</code> cache to the decorated <code>typer</code> command function.</p> <p>Parameters:</p> Name Type Description Default <code>show</code> <code>bool</code> <p>If set, show the cache after the function runs.</p> <code>False</code> Source code in <code>src/typerdrive/cache/attach.py</code> <pre><code>def attach_cache(show: bool = False) -&gt; Callable[[ContextFunction[P, T]], ContextFunction[P, T]]:\n    \"\"\"\n    Attach the `typerdrive` cache to the decorated `typer` command function.\n\n    Parameters:\n        show: If set, show the cache after the function runs.\n    \"\"\"\n    def _decorate(func: ContextFunction[P, T]) -&gt; ContextFunction[P, T]:\n        manager_param_key: str | None = None\n        for key in func.__annotations__.keys():\n            if func.__annotations__[key] is CacheManager:\n                func.__annotations__[key] = Annotated[CacheManager | None, CloakingDevice]\n                manager_param_key = key\n\n        @wraps(func)\n        def wrapper(ctx: typer.Context, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n            manager: CacheManager = CacheManager()\n            to_context(ctx, \"cache_manager\", manager)\n\n            if manager_param_key:\n                kwargs[manager_param_key] = manager\n\n            ret_val = func(ctx, *args, **kwargs)\n\n            if show:\n                show_directory(manager.cache_dir, subject=\"Current cache\")\n\n            return ret_val\n\n        return wrapper\n\n    return _decorate\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.attach.get_cache_manager","title":"get_cache_manager","text":"<pre><code>get_cache_manager(ctx: Context) -&gt; CacheManager\n</code></pre> <p>Retrieve the <code>CacheManager</code> from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/cache/attach.py</code> <pre><code>def get_cache_manager(ctx: typer.Context) -&gt; CacheManager:\n    \"\"\"\n    Retrieve the `CacheManager` from the `TyperdriveContext`.\n    \"\"\"\n    with CacheError.handle_errors(\"Cache is not bound to the context. Use the @attach_cache() decorator\"):\n        mgr: Any = from_context(ctx, \"cache_manager\")\n    return CacheError.ensure_type(\n        mgr,\n        CacheManager,\n        \"Item in user context at `cache_manager` was not a CacheManager\",\n    )\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.commands","title":"typerdrive.cache.commands","text":"<p>Provide commands that can be added to a <code>typer</code> app to interact with the cache.</p>"},{"location":"reference/cache/#typerdrive.cache.commands-classes","title":"Classes","text":""},{"location":"reference/cache/#typerdrive.cache.commands-functions","title":"Functions","text":""},{"location":"reference/cache/#typerdrive.cache.commands.add_cache_subcommand","title":"add_cache_subcommand","text":"<pre><code>add_cache_subcommand(cli: Typer)\n</code></pre> <p>Add all <code>cache</code> subcommands to the given app.</p> Source code in <code>src/typerdrive/cache/commands.py</code> <pre><code>def add_cache_subcommand(cli: typer.Typer):\n    \"\"\"\n    Add all `cache` subcommands to the given app.\n    \"\"\"\n    cache_cli = typer.Typer(help=\"Manage cache for the app\")\n\n    for cmd in [add_clear, add_show]:\n        cmd(cache_cli)\n\n    cli.add_typer(cache_cli, name=\"cache\")\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.commands.add_clear","title":"add_clear","text":"<pre><code>add_clear(cli: Typer)\n</code></pre> <p>Add the <code>clear</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/cache/commands.py</code> <pre><code>def add_clear(cli: typer.Typer):\n    \"\"\"\n    Add the `clear` command to the given `typer` app.\n    \"\"\"\n    cli.command()(clear)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.commands.add_show","title":"add_show","text":"<pre><code>add_show(cli: Typer)\n</code></pre> <p>Add the <code>show</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/cache/commands.py</code> <pre><code>def add_show(cli: typer.Typer):\n    \"\"\"\n    Add the `show` command to the given `typer` app.\n    \"\"\"\n    cli.command()(show)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.commands.clear","title":"clear","text":"<pre><code>clear(\n    ctx: Context,\n    path: Annotated[\n        str | None,\n        Option(\n            help=\"Clear only the entry matching this path. If not provided, clear the entire cache\"\n        ),\n    ] = None,\n)\n</code></pre> <p>Remove data from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Annotated[str | None, Option(help='Clear only the entry matching this path. If not provided, clear the entire cache')]</code> <p>If provided, only remove the data at the given cache key. Otherwise, clear the entire cache.</p> <code>None</code> Source code in <code>src/typerdrive/cache/commands.py</code> <pre><code>@handle_errors(\"Failed to clear cache\", handle_exc_class=CacheError)\n@attach_cache()\ndef clear(\n    ctx: typer.Context,\n    path: Annotated[\n        str | None,\n        typer.Option(help=\"Clear only the entry matching this path. If not provided, clear the entire cache\"),\n    ] = None,\n):\n    \"\"\"\n    Remove data from the cache.\n\n    Parameters:\n        path: If provided, only remove the data at the given cache key. Otherwise, clear the entire cache.\n    \"\"\"\n    manager: CacheManager = get_cache_manager(ctx)\n    if path:\n        manager.clear_path(path)\n        terminal_message(f\"Cleared entry at cache target {str(path)}\")\n    else:\n        typer.confirm(\"Are you sure you want to clear the entire cache?\", abort=True)\n        count = manager.clear_all()\n        terminal_message(f\"Cleared all {count} files from cache\")\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.commands.show","title":"show","text":"<pre><code>show(ctx: Context)\n</code></pre> <p>Show the current cache directory.</p> Source code in <code>src/typerdrive/cache/commands.py</code> <pre><code>@handle_errors(\"Failed to show cache\", handle_exc_class=CacheError)\n@attach_cache(show=True)\ndef show(ctx: typer.Context):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Show the current cache directory.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions","title":"typerdrive.cache.exceptions","text":"<p>Provide exceptions specific to the cache feature of <code>typerdrive</code>.</p>"},{"location":"reference/cache/#typerdrive.cache.exceptions-classes","title":"Classes","text":""},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheClearError","title":"CacheClearError","text":"<p>               Bases: <code>CacheError</code></p> <p>Indicate that there was a problem clearing data from the cache.</p> Source code in <code>src/typerdrive/cache/exceptions.py</code> <pre><code>class CacheClearError(CacheError):\n    \"\"\"\n    Indicate that there was a problem clearing data from the cache.\n    \"\"\"\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheError","title":"CacheError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>The base exception for cache errors.</p> Source code in <code>src/typerdrive/cache/exceptions.py</code> <pre><code>class CacheError(TyperdriveError):\n    \"\"\"\n    The base exception for cache errors.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.GENERAL_ERROR\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheError-attributes","title":"Attributes","text":""},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = GENERAL_ERROR\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheInitError","title":"CacheInitError","text":"<p>               Bases: <code>CacheError</code></p> <p>Indicate that there was a problem initializing the cache.</p> Source code in <code>src/typerdrive/cache/exceptions.py</code> <pre><code>class CacheInitError(CacheError):\n    \"\"\"\n    Indicate that there was a problem initializing the cache.\n    \"\"\"\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheLoadError","title":"CacheLoadError","text":"<p>               Bases: <code>CacheError</code></p> <p>Indicate that there was a problem loading data from the cache.</p> Source code in <code>src/typerdrive/cache/exceptions.py</code> <pre><code>class CacheLoadError(CacheError):\n    \"\"\"\n    Indicate that there was a problem loading data from the cache.\n    \"\"\"\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.exceptions.CacheStoreError","title":"CacheStoreError","text":"<p>               Bases: <code>CacheError</code></p> <p>Indicate that there was a problem storing data in the cache.</p> Source code in <code>src/typerdrive/cache/exceptions.py</code> <pre><code>class CacheStoreError(CacheError):\n    \"\"\"\n    Indicate that there was a problem storing data in the cache.\n    \"\"\"\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager","title":"typerdrive.cache.manager","text":"<p>Provide a class for managing the <code>typerdrive</code> cache feature.</p>"},{"location":"reference/cache/#typerdrive.cache.manager-classes","title":"Classes","text":""},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager","title":"CacheManager","text":"<p>Manage the <code>typerdrive</code> cache feature.</p> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>class CacheManager:\n    \"\"\"\n    Manage the `typerdrive` cache feature.\n    \"\"\"\n\n    cache_dir: Path\n    \"\"\" The directory where the cache is found. \"\"\"\n\n    def __init__(self):\n        config: TyperdriveConfig = get_typerdrive_config()\n\n        self.cache_dir = config.cache_dir\n\n        with CacheInitError.handle_errors(\"Failed to initialize cache\"):\n            self.cache_dir.mkdir(parents=True, exist_ok=True)\n\n    def resolve_path(self, path: Path | str, mkdir: bool = False) -&gt; Path:\n        \"\"\"\n        Resolve a given cache key path to an absolute path within the cache directory.\n\n        If the resolved path is outside the cache directory, an exception will be raised.\n        If the resolved path is the same as the cache directory, an exception will be raised.\n\n        Parameters:\n            path:  The cache key\n            mkdir: If set, create the directory for the cache key if it does not exist.\n        \"\"\"\n        if isinstance(path, str):\n            path = Path(path)\n        full_path = self.cache_dir / path\n        full_path = full_path.resolve()\n        CacheError.require_condition(\n            is_child(full_path, self.cache_dir),\n            f\"Resolved cache path {str(full_path)} is not within cache {str(self.cache_dir)}\",\n        )\n        CacheError.require_condition(\n            full_path != self.cache_dir,\n            f\"Resolved cache path {str(full_path)} must not be the same as cache {str(self.cache_dir)}\",\n        )\n        if mkdir:\n            full_path.parent.mkdir(parents=True, exist_ok=True)\n        return full_path\n\n    def list_items(self, path: Path | str) -&gt; list[str]:\n        \"\"\"\n        List items at a given path.\n\n        Items will be all non-directory entries in the given path.\n\n        If the path doesn't exist or is not a directory, an exception will be raised.\n        \"\"\"\n        full_path = self.resolve_path(path)\n        CacheError.require_condition(\n            full_path.exists(),\n            f\"Resolved cache path {str(full_path)} does not exist\",\n        )\n        CacheError.require_condition(\n            full_path.is_dir(),\n            \"Resolved cache path {str(full_path)} is not a directory\",\n        )\n        items: list[str] = []\n        for path in full_path.iterdir():\n            if path.is_dir():\n                continue\n            items.append(str(path.name))\n        return items\n\n    def store_bytes(self, data: bytes, path: Path | str, mode: int | None = None):\n        \"\"\"\n        Store data at the given cache key.\n\n        Parameters:\n            data: The data to store in the cache\n            path: The cache key where the data should be stored\n            mode: The file mode to use when creating the cache entry\n        \"\"\"\n        full_path = self.resolve_path(path, mkdir=True)\n\n        logger.debug(f\"Storing data at {full_path}\")\n\n        with CacheStoreError.handle_errors(f\"Failed to store data in cache target {str(path)}\"):\n            full_path.write_bytes(data)\n        if mode:\n            with CacheStoreError.handle_errors(f\"Failed to set mode for cache target {str(path)} to {mode=}\"):\n                full_path.chmod(mode)\n\n    def store_text(self, text: str, path: Path | str, mode: int | None = None):\n        \"\"\"\n        Store text at the given cache key.\n\n        Parameters:\n            text: The text to store in the cache\n            path: The cache key where the text should be stored\n            mode: The file mode to use when creating the cache entry\n        \"\"\"\n        self.store_bytes(text.encode(\"utf-8\"), path, mode=mode)\n\n    def store_json(self, data: dict[str, Any], path: Path | str, mode: int | None = None):\n        \"\"\"\n        Store a dictionary at the given cache key.\n\n        The dictionary must be json serializable.\n\n        Parameters:\n            data: The dict to store in the cache\n            path: The cache key where the dict should be stored\n            mode: The file mode to use when creating the cache entry\n        \"\"\"\n        self.store_bytes(json.dumps(data, indent=2).encode(\"utf-8\"), path, mode=mode)\n\n    def load_bytes(self, path: Path | str) -&gt; bytes:\n        \"\"\"\n        Load data from the cache at the given key.\n\n        If there is no data at the given key, an exception will be raised.\n        If there is an error reading the data, an exception will be raised.\n\n        Parameters:\n            path: The cache key where the data should be loaded from\n        \"\"\"\n        full_path = self.resolve_path(path, mkdir=False)\n\n        logger.debug(f\"Loading data from {full_path}\")\n\n        CacheLoadError.require_condition(full_path.exists(), f\"Cache target {str(path)} does not exist\")\n        with CacheLoadError.handle_errors(f\"Failed to load data from cache target {str(path)}\"):\n            return full_path.read_bytes()\n\n    def load_text(self, path: Path | str) -&gt; str:\n        \"\"\"\n        Load text from the cache at the given key.\n\n        Parameters:\n            path: The cache key where the text should be loaded from\n        \"\"\"\n        return self.load_bytes(path).decode(\"utf-8\")\n\n    def load_json(self, path: Path | str) -&gt; dict[str, Any]:\n        \"\"\"\n        Load a dictionary from the cache at the given key.\n\n        The data at the given key must be json deserializable.\n\n        Parameters:\n            path: The cache key where the dict should be loaded from\n        \"\"\"\n        text = self.load_bytes(path).decode(\"utf-8\")\n        with CacheLoadError.handle_errors(f\"Failed to unpack JSON data from cache target {str(path)}\"):\n            return json.loads(text)\n\n    def clear_path(self, path: Path | str) -&gt; Path:\n        \"\"\"\n        Removes data from the cache at the given key.\n\n        Parameters:\n            path: The cache key where the data should be cleared\n        \"\"\"\n        full_path = self.resolve_path(path)\n\n        logger.debug(f\"Clearing data at {full_path}\")\n\n        with CacheClearError.handle_errors(f\"Failed to clear cache target {str(path)}\"):\n            full_path.unlink()\n        if len([p for p in full_path.parent.iterdir()]) == 0:\n            with CacheClearError.handle_errors(f\"Failed to remove empty directory {str(full_path.parent)}\"):\n                full_path.parent.rmdir()\n        return full_path\n\n    def clear_all(self) -&gt; int:\n        \"\"\"\n        Removes all data from the cache.\n        \"\"\"\n        logger.debug(\"Clearing entire cache\")\n        with CacheClearError.handle_errors(\"Failed to clear cache\"):\n            return clear_directory(self.cache_dir)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager-attributes","title":"Attributes","text":""},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.cache_dir","title":"cache_dir  <code>instance-attribute</code>","text":"<pre><code>cache_dir: Path = cache_dir\n</code></pre> <p>The directory where the cache is found.</p>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager-functions","title":"Functions","text":""},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def __init__(self):\n    config: TyperdriveConfig = get_typerdrive_config()\n\n    self.cache_dir = config.cache_dir\n\n    with CacheInitError.handle_errors(\"Failed to initialize cache\"):\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.clear_all","title":"clear_all","text":"<pre><code>clear_all() -&gt; int\n</code></pre> <p>Removes all data from the cache.</p> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def clear_all(self) -&gt; int:\n    \"\"\"\n    Removes all data from the cache.\n    \"\"\"\n    logger.debug(\"Clearing entire cache\")\n    with CacheClearError.handle_errors(\"Failed to clear cache\"):\n        return clear_directory(self.cache_dir)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.clear_path","title":"clear_path","text":"<pre><code>clear_path(path: Path | str) -&gt; Path\n</code></pre> <p>Removes data from the cache at the given key.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The cache key where the data should be cleared</p> required Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def clear_path(self, path: Path | str) -&gt; Path:\n    \"\"\"\n    Removes data from the cache at the given key.\n\n    Parameters:\n        path: The cache key where the data should be cleared\n    \"\"\"\n    full_path = self.resolve_path(path)\n\n    logger.debug(f\"Clearing data at {full_path}\")\n\n    with CacheClearError.handle_errors(f\"Failed to clear cache target {str(path)}\"):\n        full_path.unlink()\n    if len([p for p in full_path.parent.iterdir()]) == 0:\n        with CacheClearError.handle_errors(f\"Failed to remove empty directory {str(full_path.parent)}\"):\n            full_path.parent.rmdir()\n    return full_path\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.list_items","title":"list_items","text":"<pre><code>list_items(path: Path | str) -&gt; list[str]\n</code></pre> <p>List items at a given path.</p> <p>Items will be all non-directory entries in the given path.</p> <p>If the path doesn't exist or is not a directory, an exception will be raised.</p> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def list_items(self, path: Path | str) -&gt; list[str]:\n    \"\"\"\n    List items at a given path.\n\n    Items will be all non-directory entries in the given path.\n\n    If the path doesn't exist or is not a directory, an exception will be raised.\n    \"\"\"\n    full_path = self.resolve_path(path)\n    CacheError.require_condition(\n        full_path.exists(),\n        f\"Resolved cache path {str(full_path)} does not exist\",\n    )\n    CacheError.require_condition(\n        full_path.is_dir(),\n        \"Resolved cache path {str(full_path)} is not a directory\",\n    )\n    items: list[str] = []\n    for path in full_path.iterdir():\n        if path.is_dir():\n            continue\n        items.append(str(path.name))\n    return items\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.load_bytes","title":"load_bytes","text":"<pre><code>load_bytes(path: Path | str) -&gt; bytes\n</code></pre> <p>Load data from the cache at the given key.</p> <p>If there is no data at the given key, an exception will be raised. If there is an error reading the data, an exception will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The cache key where the data should be loaded from</p> required Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def load_bytes(self, path: Path | str) -&gt; bytes:\n    \"\"\"\n    Load data from the cache at the given key.\n\n    If there is no data at the given key, an exception will be raised.\n    If there is an error reading the data, an exception will be raised.\n\n    Parameters:\n        path: The cache key where the data should be loaded from\n    \"\"\"\n    full_path = self.resolve_path(path, mkdir=False)\n\n    logger.debug(f\"Loading data from {full_path}\")\n\n    CacheLoadError.require_condition(full_path.exists(), f\"Cache target {str(path)} does not exist\")\n    with CacheLoadError.handle_errors(f\"Failed to load data from cache target {str(path)}\"):\n        return full_path.read_bytes()\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.load_json","title":"load_json","text":"<pre><code>load_json(path: Path | str) -&gt; dict[str, Any]\n</code></pre> <p>Load a dictionary from the cache at the given key.</p> <p>The data at the given key must be json deserializable.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The cache key where the dict should be loaded from</p> required Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def load_json(self, path: Path | str) -&gt; dict[str, Any]:\n    \"\"\"\n    Load a dictionary from the cache at the given key.\n\n    The data at the given key must be json deserializable.\n\n    Parameters:\n        path: The cache key where the dict should be loaded from\n    \"\"\"\n    text = self.load_bytes(path).decode(\"utf-8\")\n    with CacheLoadError.handle_errors(f\"Failed to unpack JSON data from cache target {str(path)}\"):\n        return json.loads(text)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.load_text","title":"load_text","text":"<pre><code>load_text(path: Path | str) -&gt; str\n</code></pre> <p>Load text from the cache at the given key.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The cache key where the text should be loaded from</p> required Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def load_text(self, path: Path | str) -&gt; str:\n    \"\"\"\n    Load text from the cache at the given key.\n\n    Parameters:\n        path: The cache key where the text should be loaded from\n    \"\"\"\n    return self.load_bytes(path).decode(\"utf-8\")\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.resolve_path","title":"resolve_path","text":"<pre><code>resolve_path(path: Path | str, mkdir: bool = False) -&gt; Path\n</code></pre> <p>Resolve a given cache key path to an absolute path within the cache directory.</p> <p>If the resolved path is outside the cache directory, an exception will be raised. If the resolved path is the same as the cache directory, an exception will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The cache key</p> required <code>mkdir</code> <code>bool</code> <p>If set, create the directory for the cache key if it does not exist.</p> <code>False</code> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def resolve_path(self, path: Path | str, mkdir: bool = False) -&gt; Path:\n    \"\"\"\n    Resolve a given cache key path to an absolute path within the cache directory.\n\n    If the resolved path is outside the cache directory, an exception will be raised.\n    If the resolved path is the same as the cache directory, an exception will be raised.\n\n    Parameters:\n        path:  The cache key\n        mkdir: If set, create the directory for the cache key if it does not exist.\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n    full_path = self.cache_dir / path\n    full_path = full_path.resolve()\n    CacheError.require_condition(\n        is_child(full_path, self.cache_dir),\n        f\"Resolved cache path {str(full_path)} is not within cache {str(self.cache_dir)}\",\n    )\n    CacheError.require_condition(\n        full_path != self.cache_dir,\n        f\"Resolved cache path {str(full_path)} must not be the same as cache {str(self.cache_dir)}\",\n    )\n    if mkdir:\n        full_path.parent.mkdir(parents=True, exist_ok=True)\n    return full_path\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.store_bytes","title":"store_bytes","text":"<pre><code>store_bytes(\n    data: bytes, path: Path | str, mode: int | None = None\n)\n</code></pre> <p>Store data at the given cache key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to store in the cache</p> required <code>path</code> <code>Path | str</code> <p>The cache key where the data should be stored</p> required <code>mode</code> <code>int | None</code> <p>The file mode to use when creating the cache entry</p> <code>None</code> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def store_bytes(self, data: bytes, path: Path | str, mode: int | None = None):\n    \"\"\"\n    Store data at the given cache key.\n\n    Parameters:\n        data: The data to store in the cache\n        path: The cache key where the data should be stored\n        mode: The file mode to use when creating the cache entry\n    \"\"\"\n    full_path = self.resolve_path(path, mkdir=True)\n\n    logger.debug(f\"Storing data at {full_path}\")\n\n    with CacheStoreError.handle_errors(f\"Failed to store data in cache target {str(path)}\"):\n        full_path.write_bytes(data)\n    if mode:\n        with CacheStoreError.handle_errors(f\"Failed to set mode for cache target {str(path)} to {mode=}\"):\n            full_path.chmod(mode)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.store_json","title":"store_json","text":"<pre><code>store_json(\n    data: dict[str, Any],\n    path: Path | str,\n    mode: int | None = None,\n)\n</code></pre> <p>Store a dictionary at the given cache key.</p> <p>The dictionary must be json serializable.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dict to store in the cache</p> required <code>path</code> <code>Path | str</code> <p>The cache key where the dict should be stored</p> required <code>mode</code> <code>int | None</code> <p>The file mode to use when creating the cache entry</p> <code>None</code> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def store_json(self, data: dict[str, Any], path: Path | str, mode: int | None = None):\n    \"\"\"\n    Store a dictionary at the given cache key.\n\n    The dictionary must be json serializable.\n\n    Parameters:\n        data: The dict to store in the cache\n        path: The cache key where the dict should be stored\n        mode: The file mode to use when creating the cache entry\n    \"\"\"\n    self.store_bytes(json.dumps(data, indent=2).encode(\"utf-8\"), path, mode=mode)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager.CacheManager.store_text","title":"store_text","text":"<pre><code>store_text(\n    text: str, path: Path | str, mode: int | None = None\n)\n</code></pre> <p>Store text at the given cache key.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to store in the cache</p> required <code>path</code> <code>Path | str</code> <p>The cache key where the text should be stored</p> required <code>mode</code> <code>int | None</code> <p>The file mode to use when creating the cache entry</p> <code>None</code> Source code in <code>src/typerdrive/cache/manager.py</code> <pre><code>def store_text(self, text: str, path: Path | str, mode: int | None = None):\n    \"\"\"\n    Store text at the given cache key.\n\n    Parameters:\n        text: The text to store in the cache\n        path: The cache key where the text should be stored\n        mode: The file mode to use when creating the cache entry\n    \"\"\"\n    self.store_bytes(text.encode(\"utf-8\"), path, mode=mode)\n</code></pre>"},{"location":"reference/cache/#typerdrive.cache.manager-functions","title":"Functions","text":""},{"location":"reference/client/","title":"typerdrive Client modules","text":""},{"location":"reference/client/#typerdrive.client.attach","title":"typerdrive.client.attach","text":"<p>Provide a decorator that attaches <code>TyperdriveClient</code> instances to a <code>typer</code> command function.</p>"},{"location":"reference/client/#typerdrive.client.attach-attributes","title":"Attributes","text":""},{"location":"reference/client/#typerdrive.client.attach-classes","title":"Classes","text":""},{"location":"reference/client/#typerdrive.client.attach-functions","title":"Functions","text":""},{"location":"reference/client/#typerdrive.client.attach.attach_client","title":"attach_client","text":"<pre><code>attach_client(\n    **client_urls_or_settings_keys: str,\n) -&gt; Callable[\n    [ContextFunction[P, T]], ContextFunction[P, T]\n]\n</code></pre> <p>Attach <code>TyperdriveClient</code> instances to the decorated <code>typer</code> command function.</p> <p>Parameters:</p> Name Type Description Default <code>client_urls_or_settings_keys</code> <code>str</code> <p>A key/value mapping for base urls to use in the clients.                           The key will be the name of the client.                           The value will be either the base url to be used by the client or a key to the                           settings where the base url can be found.</p> <code>{}</code> Source code in <code>src/typerdrive/client/attach.py</code> <pre><code>def attach_client(**client_urls_or_settings_keys: str) -&gt; Callable[[ContextFunction[P, T]], ContextFunction[P, T]]:\n    \"\"\"\n    Attach `TyperdriveClient` instances to the decorated `typer` command function.\n\n    Parameters:\n        client_urls_or_settings_keys: A key/value mapping for base urls to use in the clients.\n                                      The key will be the name of the client.\n                                      The value will be either the base url to be used by the client or a key to the\n                                      settings where the base url can be found.\n    \"\"\"\n\n    def _decorate(func: ContextFunction[P, T]) -&gt; ContextFunction[P, T]:\n        manager_param_key: str | None = None\n        client_param_keys: list[str] = []\n        for key in func.__annotations__.keys():\n            if func.__annotations__[key] is TyperdriveClient:\n                if key in client_urls_or_settings_keys:\n                    func.__annotations__[key] = Annotated[TyperdriveClient | None, CloakingDevice]\n                    client_param_keys.append(key)\n\n            elif func.__annotations__[key] is ClientManager:\n                func.__annotations__[key] = Annotated[ClientManager | None, CloakingDevice]\n                manager_param_key = key\n\n        @wraps(func)\n        def wrapper(ctx: typer.Context, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n            manager = ClientManager()\n\n            settings: BaseModel | None\n            try:\n                settings = get_settings_manager(ctx).settings_instance\n            except SettingsError:\n                settings = None\n\n            for name, url_or_settings_key in client_urls_or_settings_keys.items():\n                base_url: str = getattr(settings, url_or_settings_key, url_or_settings_key)\n                with ClientError.handle_errors(\n                    f\"Couldn't use {base_url=} for client. If using a settings key, make sure settings are attached.\"\n                ):\n                    client_spec = ClientSpec(base_url=base_url)\n                manager.add_client(name, client_spec)\n\n            to_context(ctx, \"client_manager\", manager)\n\n            for key in client_param_keys:\n                kwargs[key] = manager.get_client(key)\n\n            if manager_param_key:\n                kwargs[manager_param_key] = manager\n\n            return func(ctx, *args, **kwargs)\n\n        return wrapper\n\n    return _decorate\n</code></pre>"},{"location":"reference/client/#typerdrive.client.attach.get_client","title":"get_client","text":"<pre><code>get_client(ctx: Context, name: str) -&gt; TyperdriveClient\n</code></pre> <p>Retrieve a specific <code>TyperdriveClient</code> from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/client/attach.py</code> <pre><code>def get_client(ctx: typer.Context, name: str) -&gt; TyperdriveClient:\n    \"\"\"\n    Retrieve a specific `TyperdriveClient` from the `TyperdriveContext`.\n    \"\"\"\n    return get_client_manager(ctx).get_client(name)\n</code></pre>"},{"location":"reference/client/#typerdrive.client.attach.get_client_manager","title":"get_client_manager","text":"<pre><code>get_client_manager(ctx: Context) -&gt; ClientManager\n</code></pre> <p>Retrieve the <code>ClientManager</code> from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/client/attach.py</code> <pre><code>def get_client_manager(ctx: typer.Context) -&gt; ClientManager:\n    \"\"\"\n    Retrieve the `ClientManager` from the `TyperdriveContext`.\n    \"\"\"\n    with ClientError.handle_errors(\"Client(s) are not bound to the context. Use the @attach_client() decorator\"):\n        mgr: Any = from_context(ctx, \"client_manager\")\n    return ClientError.ensure_type(\n        mgr,\n        ClientManager,\n        \"Item in user context at `client_manager` was not a ClientManager\",\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base","title":"typerdrive.client.base","text":"<p>Provide a specialized HTTP client for making requests to APIs.</p>"},{"location":"reference/client/#typerdrive.client.base-classes","title":"Classes","text":""},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient","title":"TyperdriveClient","text":"<p>               Bases: <code>Client</code></p> <p>Extend the <code>http.Client</code> with <code>*_x()</code> methods that provide useful features for processing requests.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>class TyperdriveClient(Client):\n    \"\"\"\n    Extend the `http.Client` with `*_x()` methods that provide useful features for processing requests.\n    \"\"\"\n\n    def request_x[RM: pydantic.BaseModel](\n        self,\n        method: str,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a request against an API.\n\n        Provides functionality to take url params and request body from instances of `pydantic` models.\n        Also, provides checks for the status code returned from the API.\n        Will deserialize the response into a `pydantic` model if one is provided.\n\n        Note that all the arguments of `httpx.Client` are also supported.\n\n        Parameters:\n            method:           The HTTP method to use in the request\n            url:              The url to use for the request. Will be appended to `base_url` if one has been set.\n            param_obj:        An optional `pydantic` model to use for url params. This will be serialized to JSON and\n                              passed as the request URL parameters.\n                              If set, and params are passed through another mechanism as well, an exception will be\n                              raised.\n            body_obj:         An optional `pydantic` model to use for request body. This will be serialized to JSON and\n                              passed as the request body.\n                              If set, and the body is passed through another mechanism as well, an exception will be\n                              raised.\n            expected_status:  If provided, check the response code from the API. If the code doesn't match, raise an\n                              exception.\n            expect_response:  If set, expect the response to have a JSON body that needs to be deserialized. If not set,\n                              just return the status code.\n            response_model:   If provided, deserialize the response into an instance of this model. If not provided,\n                              the return value will just be a dictionary containing the response data.\n        \"\"\"\n        logger.debug(f\"Processing {method} request to {self.base_url.join(url)}\")\n\n        if param_obj is not None:\n            logger.debug(f\"Unpacking {param_obj=} to url params\")\n\n            ClientError.require_condition(\n                \"params\" not in request_kwargs,\n                \"'params' not allowed when using param_obj\",\n            )\n            with ClientError.handle_errors(\"Param data could not be deserialized for http request\"):\n                request_kwargs[\"params\"] = param_obj.model_dump(mode=\"json\")\n\n        if body_obj is not None:\n            logger.debug(f\"Unpacking {body_obj=} to request body\")\n\n            ClientError.require_condition(\n                all(k not in request_kwargs for k in [\"data\", \"json\", \"content\"]),\n                \"'data', 'json' and 'content' not allowed when using body_obj\",\n            )\n            with ClientError.handle_errors(\"Request body data could not be deserialized for http request\"):\n                request_kwargs[\"content\"] = body_obj.model_dump_json()\n                request_kwargs[\"headers\"] = {\"Content-Type\": \"application/json\"}\n\n        with ClientError.handle_errors(\n            \"Communication with the API failed\",\n            handle_exc_class=RequestError,\n        ):\n            logger.debug(\"Issuing request\")\n            response = self.request(method, url, **request_kwargs)\n\n        if expected_status is not None:\n            logger.debug(f\"Checking response for {expected_status=}\")\n            ClientError.require_condition(\n                expected_status == response.status_code,\n                \"Got an unexpected status code: Expected {}, got {} -- {}\".format(\n                    expected_status, response.status_code, response.reason_phrase\n                ),\n                raise_kwargs=dict(details=response.text),\n            )\n\n        if not expect_response:\n            logger.debug(f\"Skipping response processing due to {expect_response=}\")\n            return response.status_code\n\n        with ClientError.handle_errors(\"Failed to unpack JSON from response\"):\n            logger.debug(\"Parsing JSON from response\")\n            data: dict[str, Any] = response.json()\n\n        if not response_model:\n            logger.debug(\"Returning raw data due to no response model being supplied\")\n            return data\n\n        with ClientError.handle_errors(\"Unexpected data in response\"):\n            logger.debug(f\"Serializing response as {response_model.__name__}\")\n            return response_model(**data)\n\n    def get_x[RM: pydantic.BaseModel](\n        self,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a GET request against an API using the `request_x()` method.\n        \"\"\"\n        return self.request_x(\n            \"GET\",\n            url,\n            param_obj=param_obj,\n            body_obj=body_obj,\n            expected_status=expected_status,\n            expect_response=expect_response,\n            response_model=response_model,\n            **request_kwargs,\n        )\n\n    def post_x[RM: pydantic.BaseModel](\n        self,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a POST request against an API using the `request_x()` method.\n        \"\"\"\n        return self.request_x(\n            \"POST\",\n            url,\n            param_obj=param_obj,\n            body_obj=body_obj,\n            expected_status=expected_status,\n            expect_response=expect_response,\n            response_model=response_model,\n            **request_kwargs,\n        )\n\n    def put_x[RM: pydantic.BaseModel](\n        self,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a PUT request against an API using the `request_x()` method.\n        \"\"\"\n        return self.request_x(\n            \"PUT\",\n            url,\n            param_obj=param_obj,\n            body_obj=body_obj,\n            expected_status=expected_status,\n            expect_response=expect_response,\n            response_model=response_model,\n            **request_kwargs,\n        )\n\n    def patch_x[RM: pydantic.BaseModel](\n        self,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a PATCH request against an API using the `request_x()` method.\n        \"\"\"\n        return self.request_x(\n            \"PATCH\",\n            url,\n            param_obj=param_obj,\n            body_obj=body_obj,\n            expected_status=expected_status,\n            expect_response=expect_response,\n            response_model=response_model,\n            **request_kwargs,\n        )\n\n    def delete_x[RM: pydantic.BaseModel](\n        self,\n        url: URL | str,\n        *,\n        param_obj: pydantic.BaseModel | None = None,\n        body_obj: pydantic.BaseModel | None = None,\n        expected_status: int | None = None,\n        expect_response: bool = True,\n        response_model: type[RM] | None = None,\n        **request_kwargs: Any,\n    ) -&gt; RM | int | dict[str, Any]:\n        \"\"\"\n        Make a DELETE request against an API using the `request_x()` method.\n        \"\"\"\n        return self.request_x(\n            \"DELETE\",\n            url,\n            param_obj=param_obj,\n            body_obj=body_obj,\n            expected_status=expected_status,\n            expect_response=expect_response,\n            response_model=response_model,\n            **request_kwargs,\n        )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient-functions","title":"Functions","text":""},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.delete_x","title":"delete_x","text":"<pre><code>delete_x(\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a DELETE request against an API using the <code>request_x()</code> method.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def delete_x[RM: pydantic.BaseModel](\n    self,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a DELETE request against an API using the `request_x()` method.\n    \"\"\"\n    return self.request_x(\n        \"DELETE\",\n        url,\n        param_obj=param_obj,\n        body_obj=body_obj,\n        expected_status=expected_status,\n        expect_response=expect_response,\n        response_model=response_model,\n        **request_kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.get_x","title":"get_x","text":"<pre><code>get_x(\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a GET request against an API using the <code>request_x()</code> method.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def get_x[RM: pydantic.BaseModel](\n    self,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a GET request against an API using the `request_x()` method.\n    \"\"\"\n    return self.request_x(\n        \"GET\",\n        url,\n        param_obj=param_obj,\n        body_obj=body_obj,\n        expected_status=expected_status,\n        expect_response=expect_response,\n        response_model=response_model,\n        **request_kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.patch_x","title":"patch_x","text":"<pre><code>patch_x(\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a PATCH request against an API using the <code>request_x()</code> method.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def patch_x[RM: pydantic.BaseModel](\n    self,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a PATCH request against an API using the `request_x()` method.\n    \"\"\"\n    return self.request_x(\n        \"PATCH\",\n        url,\n        param_obj=param_obj,\n        body_obj=body_obj,\n        expected_status=expected_status,\n        expect_response=expect_response,\n        response_model=response_model,\n        **request_kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.post_x","title":"post_x","text":"<pre><code>post_x(\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a POST request against an API using the <code>request_x()</code> method.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def post_x[RM: pydantic.BaseModel](\n    self,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a POST request against an API using the `request_x()` method.\n    \"\"\"\n    return self.request_x(\n        \"POST\",\n        url,\n        param_obj=param_obj,\n        body_obj=body_obj,\n        expected_status=expected_status,\n        expect_response=expect_response,\n        response_model=response_model,\n        **request_kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.put_x","title":"put_x","text":"<pre><code>put_x(\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a PUT request against an API using the <code>request_x()</code> method.</p> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def put_x[RM: pydantic.BaseModel](\n    self,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a PUT request against an API using the `request_x()` method.\n    \"\"\"\n    return self.request_x(\n        \"PUT\",\n        url,\n        param_obj=param_obj,\n        body_obj=body_obj,\n        expected_status=expected_status,\n        expect_response=expect_response,\n        response_model=response_model,\n        **request_kwargs,\n    )\n</code></pre>"},{"location":"reference/client/#typerdrive.client.base.TyperdriveClient.request_x","title":"request_x","text":"<pre><code>request_x(\n    method: str,\n    url: URL | str,\n    *,\n    param_obj: BaseModel | None = None,\n    body_obj: BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]\n</code></pre> <p>Make a request against an API.</p> <p>Provides functionality to take url params and request body from instances of <code>pydantic</code> models. Also, provides checks for the status code returned from the API. Will deserialize the response into a <code>pydantic</code> model if one is provided.</p> <p>Note that all the arguments of <code>httpx.Client</code> are also supported.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use in the request</p> required <code>url</code> <code>URL | str</code> <p>The url to use for the request. Will be appended to <code>base_url</code> if one has been set.</p> required <code>param_obj</code> <code>BaseModel | None</code> <p>An optional <code>pydantic</code> model to use for url params. This will be serialized to JSON and               passed as the request URL parameters.               If set, and params are passed through another mechanism as well, an exception will be               raised.</p> <code>None</code> <code>body_obj</code> <code>BaseModel | None</code> <p>An optional <code>pydantic</code> model to use for request body. This will be serialized to JSON and               passed as the request body.               If set, and the body is passed through another mechanism as well, an exception will be               raised.</p> <code>None</code> <code>expected_status</code> <code>int | None</code> <p>If provided, check the response code from the API. If the code doesn't match, raise an               exception.</p> <code>None</code> <code>expect_response</code> <code>bool</code> <p>If set, expect the response to have a JSON body that needs to be deserialized. If not set,               just return the status code.</p> <code>True</code> <code>response_model</code> <code>type[RM] | None</code> <p>If provided, deserialize the response into an instance of this model. If not provided,               the return value will just be a dictionary containing the response data.</p> <code>None</code> Source code in <code>src/typerdrive/client/base.py</code> <pre><code>def request_x[RM: pydantic.BaseModel](\n    self,\n    method: str,\n    url: URL | str,\n    *,\n    param_obj: pydantic.BaseModel | None = None,\n    body_obj: pydantic.BaseModel | None = None,\n    expected_status: int | None = None,\n    expect_response: bool = True,\n    response_model: type[RM] | None = None,\n    **request_kwargs: Any,\n) -&gt; RM | int | dict[str, Any]:\n    \"\"\"\n    Make a request against an API.\n\n    Provides functionality to take url params and request body from instances of `pydantic` models.\n    Also, provides checks for the status code returned from the API.\n    Will deserialize the response into a `pydantic` model if one is provided.\n\n    Note that all the arguments of `httpx.Client` are also supported.\n\n    Parameters:\n        method:           The HTTP method to use in the request\n        url:              The url to use for the request. Will be appended to `base_url` if one has been set.\n        param_obj:        An optional `pydantic` model to use for url params. This will be serialized to JSON and\n                          passed as the request URL parameters.\n                          If set, and params are passed through another mechanism as well, an exception will be\n                          raised.\n        body_obj:         An optional `pydantic` model to use for request body. This will be serialized to JSON and\n                          passed as the request body.\n                          If set, and the body is passed through another mechanism as well, an exception will be\n                          raised.\n        expected_status:  If provided, check the response code from the API. If the code doesn't match, raise an\n                          exception.\n        expect_response:  If set, expect the response to have a JSON body that needs to be deserialized. If not set,\n                          just return the status code.\n        response_model:   If provided, deserialize the response into an instance of this model. If not provided,\n                          the return value will just be a dictionary containing the response data.\n    \"\"\"\n    logger.debug(f\"Processing {method} request to {self.base_url.join(url)}\")\n\n    if param_obj is not None:\n        logger.debug(f\"Unpacking {param_obj=} to url params\")\n\n        ClientError.require_condition(\n            \"params\" not in request_kwargs,\n            \"'params' not allowed when using param_obj\",\n        )\n        with ClientError.handle_errors(\"Param data could not be deserialized for http request\"):\n            request_kwargs[\"params\"] = param_obj.model_dump(mode=\"json\")\n\n    if body_obj is not None:\n        logger.debug(f\"Unpacking {body_obj=} to request body\")\n\n        ClientError.require_condition(\n            all(k not in request_kwargs for k in [\"data\", \"json\", \"content\"]),\n            \"'data', 'json' and 'content' not allowed when using body_obj\",\n        )\n        with ClientError.handle_errors(\"Request body data could not be deserialized for http request\"):\n            request_kwargs[\"content\"] = body_obj.model_dump_json()\n            request_kwargs[\"headers\"] = {\"Content-Type\": \"application/json\"}\n\n    with ClientError.handle_errors(\n        \"Communication with the API failed\",\n        handle_exc_class=RequestError,\n    ):\n        logger.debug(\"Issuing request\")\n        response = self.request(method, url, **request_kwargs)\n\n    if expected_status is not None:\n        logger.debug(f\"Checking response for {expected_status=}\")\n        ClientError.require_condition(\n            expected_status == response.status_code,\n            \"Got an unexpected status code: Expected {}, got {} -- {}\".format(\n                expected_status, response.status_code, response.reason_phrase\n            ),\n            raise_kwargs=dict(details=response.text),\n        )\n\n    if not expect_response:\n        logger.debug(f\"Skipping response processing due to {expect_response=}\")\n        return response.status_code\n\n    with ClientError.handle_errors(\"Failed to unpack JSON from response\"):\n        logger.debug(\"Parsing JSON from response\")\n        data: dict[str, Any] = response.json()\n\n    if not response_model:\n        logger.debug(\"Returning raw data due to no response model being supplied\")\n        return data\n\n    with ClientError.handle_errors(\"Unexpected data in response\"):\n        logger.debug(f\"Serializing response as {response_model.__name__}\")\n        return response_model(**data)\n</code></pre>"},{"location":"reference/client/#typerdrive.client.exceptions","title":"typerdrive.client.exceptions","text":"<p>Provide exceptions specific to the client feature of <code>typerdrive</code>.</p>"},{"location":"reference/client/#typerdrive.client.exceptions-classes","title":"Classes","text":""},{"location":"reference/client/#typerdrive.client.exceptions.ClientError","title":"ClientError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>The base exception for client errors.</p> Source code in <code>src/typerdrive/client/exceptions.py</code> <pre><code>class ClientError(TyperdriveError):\n    \"\"\"\n    The base exception for client errors.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.GENERAL_ERROR\n</code></pre>"},{"location":"reference/client/#typerdrive.client.exceptions.ClientError-attributes","title":"Attributes","text":""},{"location":"reference/client/#typerdrive.client.exceptions.ClientError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = GENERAL_ERROR\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager","title":"typerdrive.client.manager","text":"<p>Provide a class for managing the <code>typerdrive</code> client feature.</p>"},{"location":"reference/client/#typerdrive.client.manager-classes","title":"Classes","text":""},{"location":"reference/client/#typerdrive.client.manager.ClientManager","title":"ClientManager","text":"<p>Manage instances of <code>TyperdriveClient</code>.</p> Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>class ClientManager:\n    \"\"\"\n    Manage instances of `TyperdriveClient`.\n    \"\"\"\n\n    clients: dict[str, TyperdriveClient]\n    \"\"\" The `TyperdriveClient instances to manage. \"\"\"\n\n    def __init__(self):\n        self.clients = {}\n\n    def add_client(self, name: str, spec: ClientSpec) -&gt; None:\n        \"\"\"\n        Add a `TyperdriveClient` under the given name.\n\n        Parameters:\n            name: The name of the client\n            spec: A `ClientSpec` describing the client. Used to validate the specs.\n        \"\"\"\n        ClientError.require_condition(\n            name not in self.clients,\n            f\"Client with name {name} already exists in context\",\n        )\n        self.clients[name] = TyperdriveClient(base_url=str(spec.base_url))\n\n    def get_client(self, name: str) -&gt; TyperdriveClient:\n        \"\"\"\n        Fetch a client from the manager matching the given name.\n        \"\"\"\n        return ClientError.enforce_defined(self.clients.get(name), f\"No client named {name} found in context\")\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager.ClientManager-attributes","title":"Attributes","text":""},{"location":"reference/client/#typerdrive.client.manager.ClientManager.clients","title":"clients  <code>instance-attribute</code>","text":"<pre><code>clients: dict[str, TyperdriveClient] = {}\n</code></pre> <p>The `TyperdriveClient instances to manage.</p>"},{"location":"reference/client/#typerdrive.client.manager.ClientManager-functions","title":"Functions","text":""},{"location":"reference/client/#typerdrive.client.manager.ClientManager.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>def __init__(self):\n    self.clients = {}\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager.ClientManager.add_client","title":"add_client","text":"<pre><code>add_client(name: str, spec: ClientSpec) -&gt; None\n</code></pre> <p>Add a <code>TyperdriveClient</code> under the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the client</p> required <code>spec</code> <code>ClientSpec</code> <p>A <code>ClientSpec</code> describing the client. Used to validate the specs.</p> required Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>def add_client(self, name: str, spec: ClientSpec) -&gt; None:\n    \"\"\"\n    Add a `TyperdriveClient` under the given name.\n\n    Parameters:\n        name: The name of the client\n        spec: A `ClientSpec` describing the client. Used to validate the specs.\n    \"\"\"\n    ClientError.require_condition(\n        name not in self.clients,\n        f\"Client with name {name} already exists in context\",\n    )\n    self.clients[name] = TyperdriveClient(base_url=str(spec.base_url))\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager.ClientManager.get_client","title":"get_client","text":"<pre><code>get_client(name: str) -&gt; TyperdriveClient\n</code></pre> <p>Fetch a client from the manager matching the given name.</p> Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>def get_client(self, name: str) -&gt; TyperdriveClient:\n    \"\"\"\n    Fetch a client from the manager matching the given name.\n    \"\"\"\n    return ClientError.enforce_defined(self.clients.get(name), f\"No client named {name} found in context\")\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager.ClientSpec","title":"ClientSpec","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>class ClientSpec(BaseModel):\n    base_url: Annotated[str, BeforeValidator(pyright_safe_validator)]\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager.ClientSpec-attributes","title":"Attributes","text":""},{"location":"reference/client/#typerdrive.client.manager.ClientSpec.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url: Annotated[\n    str, BeforeValidator(pyright_safe_validator)\n]\n</code></pre>"},{"location":"reference/client/#typerdrive.client.manager-functions","title":"Functions","text":""},{"location":"reference/client/#typerdrive.client.manager.pyright_safe_validator","title":"pyright_safe_validator","text":"<pre><code>pyright_safe_validator(value: str) -&gt; str\n</code></pre> Source code in <code>src/typerdrive/client/manager.py</code> <pre><code>def pyright_safe_validator(value: str) -&gt; str:\n    AnyHttpUrl(value)\n    return value\n</code></pre>"},{"location":"reference/logging/","title":"typerdrive Logging modules","text":""},{"location":"reference/logging/#typerdrive.logging.attach","title":"typerdrive.logging.attach","text":"<p>Provide a decorator that attaches logging functionality to a <code>typer</code> command function.</p>"},{"location":"reference/logging/#typerdrive.logging.attach-attributes","title":"Attributes","text":""},{"location":"reference/logging/#typerdrive.logging.attach-classes","title":"Classes","text":""},{"location":"reference/logging/#typerdrive.logging.attach-functions","title":"Functions","text":""},{"location":"reference/logging/#typerdrive.logging.attach.attach_logging","title":"attach_logging","text":"<pre><code>attach_logging(\n    verbose: bool = False,\n) -&gt; Callable[\n    [ContextFunction[P, T]], ContextFunction[P, T]\n]\n</code></pre> <p>Attach a logging functinoality  to the decorated <code>typer</code> command function.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>A <code>verbose</code> flag passed along to the <code>LoggingManager</code></p> <code>False</code> Source code in <code>src/typerdrive/logging/attach.py</code> <pre><code>def attach_logging(verbose: bool = False) -&gt; Callable[[ContextFunction[P, T]], ContextFunction[P, T]]:\n    \"\"\"\n    Attach a logging functinoality  to the decorated `typer` command function.\n\n    Parameters:\n        verbose: A `verbose` flag passed along to the `LoggingManager`\n    \"\"\"\n    def _decorate(func: ContextFunction[P, T]) -&gt; ContextFunction[P, T]:\n        manager_param_key: str | None = None\n        for key in func.__annotations__.keys():\n            if func.__annotations__[key] is LoggingManager:\n                func.__annotations__[key] = Annotated[LoggingManager | None, CloakingDevice]\n                manager_param_key = key\n\n        @wraps(func)\n        def wrapper(ctx: typer.Context, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n            manager: LoggingManager = LoggingManager(verbose=verbose)\n            to_context(ctx, \"logging_manager\", manager)\n\n            logger.debug(\"Logging attached to typer context\")\n\n            if manager_param_key:\n                kwargs[manager_param_key] = manager\n\n            return func(ctx, *args, **kwargs)\n\n        return wrapper\n\n    return _decorate\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.attach.get_logging_manager","title":"get_logging_manager","text":"<pre><code>get_logging_manager(ctx: Context) -&gt; LoggingManager\n</code></pre> <p>Retrieve the <code>LoggingManager</code> from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/logging/attach.py</code> <pre><code>def get_logging_manager(ctx: typer.Context) -&gt; LoggingManager:\n    \"\"\"\n    Retrieve the `LoggingManager` from the `TyperdriveContext`.\n    \"\"\"\n    with LoggingError.handle_errors(\"Logging is not bound to the context. Use the @attach_logging() decorator\"):\n        mgr: Any = from_context(ctx, \"logging_manager\")\n    return LoggingError.ensure_type(\n        mgr,\n        LoggingManager,\n        \"Item in user context at `logging_manager` was not a LoggingManager\",\n    )\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands","title":"typerdrive.logging.commands","text":"<p>Provide commands that can be added to a <code>typer</code> app to manage logs.</p>"},{"location":"reference/logging/#typerdrive.logging.commands-classes","title":"Classes","text":""},{"location":"reference/logging/#typerdrive.logging.commands-functions","title":"Functions","text":""},{"location":"reference/logging/#typerdrive.logging.commands.add_audit","title":"add_audit","text":"<pre><code>add_audit(cli: Typer)\n</code></pre> <p>Add the <code>audit</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>def add_audit(cli: typer.Typer):\n    \"\"\"\n    Add the `audit` command to the given `typer` app.\n    \"\"\"\n    cli.command()(audit)\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.add_clear","title":"add_clear","text":"<pre><code>add_clear(cli: Typer)\n</code></pre> <p>Add the <code>clear</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>def add_clear(cli: typer.Typer):\n    \"\"\"\n    Add the `clear` command to the given `typer` app.\n    \"\"\"\n    cli.command()(clear)\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.add_logs_subcommand","title":"add_logs_subcommand","text":"<pre><code>add_logs_subcommand(cli: Typer)\n</code></pre> <p>Add all <code>logs</code> commands to the given app.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>def add_logs_subcommand(cli: typer.Typer):\n    \"\"\"\n    Add all `logs` commands to the given app.\n    \"\"\"\n    logs_cli = typer.Typer(help=\"Manage logs for the app\")\n\n    for cmd in [add_clear, add_show, add_audit]:\n        cmd(logs_cli)\n\n    cli.add_typer(logs_cli, name=\"logs\")\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.add_show","title":"add_show","text":"<pre><code>add_show(cli: Typer)\n</code></pre> <p>Add the <code>show</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>def add_show(cli: typer.Typer):\n    \"\"\"\n    Add the `show` command to the given `typer` app.\n    \"\"\"\n    cli.command()(show)\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.audit","title":"audit","text":"<pre><code>audit(ctx: Context, manager: LoggingManager)\n</code></pre> <p>Show the log files retained for the app.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>@handle_errors(\"Failed to audit log dir\", handle_exc_class=LoggingError)\n@attach_logging()\ndef audit(ctx: typer.Context, manager: LoggingManager):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Show the log files retained for the app.\n    \"\"\"\n    manager.audit()\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.clear","title":"clear","text":"<pre><code>clear(ctx: Context, manager: LoggingManager)\n</code></pre> <p>Clear all the log files.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>@handle_errors(\"Failed to clear log dir\", handle_exc_class=LoggingError)\n@attach_logging()\ndef clear(ctx: typer.Context, manager: LoggingManager):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Clear all the log files.\n    \"\"\"\n    typer.confirm(\"Are you sure you want to clear all log files from the log directory?\", abort=True)\n    manager.clear()\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.commands.show","title":"show","text":"<pre><code>show(ctx: Context, manager: LoggingManager)\n</code></pre> <p>Show the current log.</p> Source code in <code>src/typerdrive/logging/commands.py</code> <pre><code>@handle_errors(\"Failed to show log\", handle_exc_class=LoggingError)\n@attach_logging()\ndef show(ctx: typer.Context, manager: LoggingManager):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Show the current log.\n    \"\"\"\n    manager.show()\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.exceptions","title":"typerdrive.logging.exceptions","text":"<p>Provide exceptions specific to the logging feature of <code>typerdrive</code>.</p>"},{"location":"reference/logging/#typerdrive.logging.exceptions-classes","title":"Classes","text":""},{"location":"reference/logging/#typerdrive.logging.exceptions.LoggingError","title":"LoggingError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>The base exception for logging errors.</p> Source code in <code>src/typerdrive/logging/exceptions.py</code> <pre><code>class LoggingError(TyperdriveError):\n    \"\"\"\n    The base exception for logging errors.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.GENERAL_ERROR\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.exceptions.LoggingError-attributes","title":"Attributes","text":""},{"location":"reference/logging/#typerdrive.logging.exceptions.LoggingError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = GENERAL_ERROR\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager","title":"typerdrive.logging.manager","text":"<p>Provide a class for managing the <code>typerdrive</code> logging feature.</p>"},{"location":"reference/logging/#typerdrive.logging.manager-classes","title":"Classes","text":""},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager","title":"LoggingManager","text":"<p>Manage logs for the <code>typerdrive</code> app.</p> Source code in <code>src/typerdrive/logging/manager.py</code> <pre><code>class LoggingManager:\n    \"\"\"\n    Manage logs for the `typerdrive` app.\n    \"\"\"\n\n    log_dir: Path\n    \"\"\" The directory where the logs are stored. \"\"\"\n\n    log_file: Path\n    \"\"\" The filename for the log file. \"\"\"\n\n    def __init__(self, *, verbose: bool = False):\n        config: TyperdriveConfig = get_typerdrive_config()\n\n        self.log_dir = config.log_dir\n        self.log_file = config.log_dir / config.log_file_name\n\n        handlers: list[dict[str, Any]] = [\n            dict(\n                sink=str(self.log_file),\n                level=\"DEBUG\",\n                rotation=config.log_file_rotation,\n                retention=config.log_file_retention,\n                compression=config.log_file_compression,\n            ),\n        ]\n        if verbose:\n            handlers.append(\n                dict(\n                    sink=sys.stdout,\n                    level=\"DEBUG\",\n                    format=\"&lt;green&gt;{time:HH:mm:ss}&lt;/green&gt; | &lt;level&gt;{level}&lt;/level&gt; | &lt;level&gt;{message}&lt;/level&gt;\"\n                ),\n            )\n\n        # Having a hell of a time getting the typing right for `configure()`\n        logger.configure(handlers=handlers)  # type: ignore[arg-type]  # pyright: ignore[reportArgumentType]\n        logger.enable(\"typerdrive\")\n\n    def show(self):\n        \"\"\"\n        Show the current log file.\n        \"\"\"\n        console = Console()\n        with console.pager(styles=True):\n            console.print(self.log_file.read_text())\n\n    def audit(self):\n        \"\"\"\n        Show the directory containing the log files.\n        \"\"\"\n        show_directory(self.log_dir, subject=\"Current log files\")\n\n    def clear(self):\n        \"\"\"\n        Remove all log files.\n        \"\"\"\n        clear_directory(self.log_dir)\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager-attributes","title":"Attributes","text":""},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.log_dir","title":"log_dir  <code>instance-attribute</code>","text":"<pre><code>log_dir: Path = log_dir\n</code></pre> <p>The directory where the logs are stored.</p>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.log_file","title":"log_file  <code>instance-attribute</code>","text":"<pre><code>log_file: Path = log_dir / log_file_name\n</code></pre> <p>The filename for the log file.</p>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager-functions","title":"Functions","text":""},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.__init__","title":"__init__","text":"<pre><code>__init__(*, verbose: bool = False)\n</code></pre> Source code in <code>src/typerdrive/logging/manager.py</code> <pre><code>def __init__(self, *, verbose: bool = False):\n    config: TyperdriveConfig = get_typerdrive_config()\n\n    self.log_dir = config.log_dir\n    self.log_file = config.log_dir / config.log_file_name\n\n    handlers: list[dict[str, Any]] = [\n        dict(\n            sink=str(self.log_file),\n            level=\"DEBUG\",\n            rotation=config.log_file_rotation,\n            retention=config.log_file_retention,\n            compression=config.log_file_compression,\n        ),\n    ]\n    if verbose:\n        handlers.append(\n            dict(\n                sink=sys.stdout,\n                level=\"DEBUG\",\n                format=\"&lt;green&gt;{time:HH:mm:ss}&lt;/green&gt; | &lt;level&gt;{level}&lt;/level&gt; | &lt;level&gt;{message}&lt;/level&gt;\"\n            ),\n        )\n\n    # Having a hell of a time getting the typing right for `configure()`\n    logger.configure(handlers=handlers)  # type: ignore[arg-type]  # pyright: ignore[reportArgumentType]\n    logger.enable(\"typerdrive\")\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.audit","title":"audit","text":"<pre><code>audit()\n</code></pre> <p>Show the directory containing the log files.</p> Source code in <code>src/typerdrive/logging/manager.py</code> <pre><code>def audit(self):\n    \"\"\"\n    Show the directory containing the log files.\n    \"\"\"\n    show_directory(self.log_dir, subject=\"Current log files\")\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Remove all log files.</p> Source code in <code>src/typerdrive/logging/manager.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Remove all log files.\n    \"\"\"\n    clear_directory(self.log_dir)\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager.LoggingManager.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Show the current log file.</p> Source code in <code>src/typerdrive/logging/manager.py</code> <pre><code>def show(self):\n    \"\"\"\n    Show the current log file.\n    \"\"\"\n    console = Console()\n    with console.pager(styles=True):\n        console.print(self.log_file.read_text())\n</code></pre>"},{"location":"reference/logging/#typerdrive.logging.manager-functions","title":"Functions","text":""},{"location":"reference/logging/#typerdrive.logging.utilities","title":"typerdrive.logging.utilities","text":"<p>Provide utility functions useful for logging.</p>"},{"location":"reference/logging/#typerdrive.logging.utilities-functions","title":"Functions","text":""},{"location":"reference/logging/#typerdrive.logging.utilities.log_error","title":"log_error","text":"<pre><code>log_error(params: DoExceptParams)\n</code></pre> <p>Log details of an error handled by the <code>@handle_errors</code> decorator.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>DoExceptParams</code> <p>An instance of <code>DoExceptParams</code> that carries the error details.     See the <code>py-byuzz</code> docs     for more context.</p> required Source code in <code>src/typerdrive/logging/utilities.py</code> <pre><code>def log_error(params: DoExceptParams):\n    \"\"\"\n    Log details of an error handled by the `@handle_errors` decorator.\n\n    Parameters:\n        params: An instance of `DoExceptParams` that carries the error details.\n                See the [`py-byuzz` docs](https://dusktreader.github.io/py-buzz/reference/#buzz.tools.DoExceptParams)\n                for more context.\n    \"\"\"\n    logger.error(\n        \"\\n\".join(\n            [\n                strip_rich_style(params.final_message),\n                \"--------\",\n                \"Traceback:\",\n                \"\".join(format_tb(params.trace)),\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/settings/","title":"typerdrive Settings modules","text":""},{"location":"reference/settings/#typerdrive.settings.attach","title":"typerdrive.settings.attach","text":"<p>Provide a decorator that attaches the <code>typerdrive</code> settings to a <code>typer</code> command function.</p>"},{"location":"reference/settings/#typerdrive.settings.attach-attributes","title":"Attributes","text":""},{"location":"reference/settings/#typerdrive.settings.attach-classes","title":"Classes","text":""},{"location":"reference/settings/#typerdrive.settings.attach-functions","title":"Functions","text":""},{"location":"reference/settings/#typerdrive.settings.attach.attach_settings","title":"attach_settings","text":"<pre><code>attach_settings(\n    settings_model: type[BaseModel],\n    *,\n    validation: Validation = Validation.BEFORE,\n    persist: bool = False,\n    show: bool = False,\n) -&gt; Callable[\n    [ContextFunction[P, T]], ContextFunction[P, T]\n]\n</code></pre> <p>Attach the <code>typerdrive</code> settings to the decorated <code>typer</code> command function.</p> <p>Parameters:</p> Name Type Description Default <code>validation</code> <code>Validation</code> <p>Indicates when validation should happen in the decorator:</p> <pre><code>    - If `BEFORE`, validate before calling the function\n    - If `AFTER`, validate after calling the function\n    - If `BOTH`, validate before and after calling the function\n    - If `NEVER`, don't validate\n</code></pre> <code>BEFORE</code> <code>persist</code> <code>bool</code> <p>If set, the settings values will be stored in the settings file</p> <code>False</code> <code>show</code> <code>bool</code> <p>If set, show the current settings after running the function</p> <code>False</code> Source code in <code>src/typerdrive/settings/attach.py</code> <pre><code>def attach_settings(\n    settings_model: type[BaseModel],\n    *,\n    validation: Validation = Validation.BEFORE,\n    persist: bool = False,\n    show: bool = False,\n) -&gt; Callable[[ContextFunction[P, T]], ContextFunction[P, T]]:\n    \"\"\"\n    Attach the `typerdrive` settings to the decorated `typer` command function.\n\n    Parameters:\n        validation: Indicates when validation should happen in the decorator:\n\n                    - If `BEFORE`, validate before calling the function\n                    - If `AFTER`, validate after calling the function\n                    - If `BOTH`, validate before and after calling the function\n                    - If `NEVER`, don't validate\n\n        persist:    If set, the settings values will be stored in the settings file\n        show:       If set, show the current settings after running the function\n    \"\"\"\n    def _decorate(func: ContextFunction[P, T]) -&gt; ContextFunction[P, T]:\n        manager_param_key: str | None = None\n        settings_param_key: str | None = None\n        for key in func.__annotations__.keys():\n            if func.__annotations__[key] is settings_model:\n                func.__annotations__[key] = Annotated[settings_model | None, CloakingDevice]\n                settings_param_key = key\n            elif func.__annotations__[key] is SettingsManager:\n                func.__annotations__[key] = Annotated[SettingsManager | None, CloakingDevice]\n                manager_param_key = key\n\n        # TODO: Figure out how we can make the ctx param optional for the wrapped function\n        @wraps(func)\n        def wrapper(ctx: typer.Context, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n            manager: SettingsManager = SettingsManager(settings_model)\n\n            if validation &amp; Validation.BEFORE:\n                SettingsError.require_condition(\n                    len(manager.invalid_warnings) == 0,\n                    f\"Initial settings are invalid: {manager.invalid_warnings}\",\n                )\n            to_context(ctx, \"settings_manager\", manager)\n\n            if settings_param_key:\n                kwargs[settings_param_key] = manager.settings_instance\n\n            if manager_param_key:\n                kwargs[manager_param_key] = manager\n\n            ret_val = func(ctx, *args, **kwargs)\n\n            if validation &amp; Validation.AFTER:\n                with SettingsError.handle_errors(\"Final settings are invalid\"):\n                    manager.validate()\n\n            if persist:\n                manager.save()\n            if show:\n                terminal_message(\n                    manager.pretty(),\n                    subject=\"Current settings\",\n                    footer=f\"saved to {manager.settings_path}\" if persist else None,\n                )\n\n            return ret_val\n\n        return wrapper\n\n    return _decorate\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.attach.get_settings","title":"get_settings","text":"<pre><code>get_settings(ctx: Context, type_hint: type[ST]) -&gt; ST\n</code></pre> <p>Get the settings instance from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/settings/attach.py</code> <pre><code>def get_settings[ST: BaseModel](\n    ctx: typer.Context,\n    type_hint: type[ST],\n) -&gt; ST:\n    \"\"\"\n    Get the settings instance from the `TyperdriveContext`.\n    \"\"\"\n    return SettingsError.ensure_type(\n        get_settings_manager(ctx).settings_instance,\n        type_hint,\n        f\"Settings instance doesn't match expected {type_hint=}\",\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.attach.get_settings_manager","title":"get_settings_manager","text":"<pre><code>get_settings_manager(ctx: Context) -&gt; SettingsManager\n</code></pre> <p>Retrieve the <code>SettingsManager</code> from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/settings/attach.py</code> <pre><code>def get_settings_manager(ctx: typer.Context) -&gt; SettingsManager:\n    \"\"\"\n    Retrieve the `SettingsManager` from the `TyperdriveContext`.\n    \"\"\"\n    with SettingsError.handle_errors(\"Settings are not bound to the context. Use the @attach_settings() decorator\"):\n        mgr: Any = from_context(ctx, \"settings_manager\")\n    return SettingsError.ensure_type(\n        mgr,\n        SettingsManager,\n        \"Item in user context at `settings_manager` was not a SettingsManager\",\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.attach.get_settings_value","title":"get_settings_value","text":"<pre><code>get_settings_value(ctx: Context, settings_key: str) -&gt; Any\n</code></pre> <p>Get a particular settings value from the <code>TyperdriveContext</code>.</p> Source code in <code>src/typerdrive/settings/attach.py</code> <pre><code>def get_settings_value(ctx: typer.Context, settings_key: str) -&gt; Any:\n    \"\"\"\n    Get a particular settings value from the `TyperdriveContext`.\n    \"\"\"\n    instance: BaseModel = get_settings_manager(ctx).settings_instance\n    ret = getattr(instance, settings_key, Sentinel.MISSING)\n    SettingsError.require_condition(\n        ret is not Sentinel.MISSING,\n        f\"Settings instance doesn't have field {settings_key}\",\n    )\n    return ret\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands","title":"typerdrive.settings.commands","text":"<p>Provide commands that can be added to a <code>typer</code> app to manage settings.</p>"},{"location":"reference/settings/#typerdrive.settings.commands-classes","title":"Classes","text":""},{"location":"reference/settings/#typerdrive.settings.commands-functions","title":"Functions","text":""},{"location":"reference/settings/#typerdrive.settings.commands.add_bind","title":"add_bind","text":"<pre><code>add_bind(cli: Typer, settings_model: type[BaseModel])\n</code></pre> <p>Add the <code>bind</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_bind(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add the `bind` command to the given `typer` app.\n    \"\"\"\n    opt_defs: list[OptDef] = []\n    for name, field_info in settings_model.model_fields.items():\n        default = field_info.default if field_info.default is not PydanticUndefined else Sentinel.NOT_GIVEN\n        param_type: type[Any] = SettingsError.enforce_defined(\n            field_info.annotation, \"Option type may not be `None`\"\n        )  # TODO: Figure out if this can even be triggered\n        opt_kwargs: dict[str, Any] = dict(\n            name=name,\n            param_type=param_type,\n            default=default,\n            help=field_info.description,\n            show_default=True,\n        )\n        if issubclass(param_type, BaseModel):\n            model_type = param_type\n            def model_parser(val: str):\n                \"\"\"\n                Provide a parser that converts a string into an instance of the nested model.\n\n                This is needed for the settings commands to be able to use nested pydantic models.\n                \"\"\"\n                return model_type(**json.loads(val))\n            opt_kwargs[\"parser\"] = model_parser\n\n        opt_defs.append(\n            OptDef(**opt_kwargs)\n        )\n    build_command(\n        cli,\n        bind,\n        *opt_defs,\n        decorators=[\n            DecDef(\n                dec_func=handle_errors,\n                dec_args=[\"Failed to bind settings\"],\n                dec_kwargs=dict(\n                    handle_exc_class=SettingsError,\n                    unwrap_message=False,\n                    debug=True,\n                ),\n                is_simple=False,\n            ),\n            DecDef(\n                dec_func=attach_settings,\n                dec_args=[settings_model],\n                dec_kwargs=dict(validation=Validation.AFTER, persist=True, show=True),\n                is_simple=False,\n            ),\n        ],\n        include_context=True,\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.add_reset","title":"add_reset","text":"<pre><code>add_reset(cli: Typer, settings_model: type[BaseModel])\n</code></pre> <p>Add the <code>reset</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_reset(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add the `reset` command to the given `typer` app.\n    \"\"\"\n    build_command(\n        cli,\n        reset,\n        decorators=[\n            DecDef(\n                dec_func=handle_errors,\n                dec_args=[\"Failed to reset settings\"],\n                dec_kwargs=dict(\n                    handle_exc_class=SettingsError,\n                    unwrap_message=False,\n                    debug=True,\n                ),\n                is_simple=False,\n            ),\n            DecDef(\n                dec_func=attach_settings,\n                dec_args=[settings_model],\n                dec_kwargs=dict(validation=Validation.NEVER, persist=True, show=True),\n                is_simple=False,\n            ),\n        ],\n        include_context=True,\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.add_settings_subcommand","title":"add_settings_subcommand","text":"<pre><code>add_settings_subcommand(\n    cli: Typer, settings_model: type[BaseModel]\n)\n</code></pre> <p>Add all <code>settings</code> commands to the given app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_settings_subcommand(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add all `settings` commands to the given app.\n    \"\"\"\n    settings_cli = typer.Typer(help=\"Manage settings for the app\")\n\n    for cmd in [add_bind, add_update, add_unset, add_reset, add_show]:\n        cmd(settings_cli, settings_model)\n\n    cli.add_typer(settings_cli, name=\"settings\")\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.add_show","title":"add_show","text":"<pre><code>add_show(cli: Typer, settings_model: type[BaseModel])\n</code></pre> <p>Add the <code>show</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_show(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add the `show` command to the given `typer` app.\n    \"\"\"\n    build_command(\n        cli,\n        show,\n        decorators=[\n            DecDef(\n                dec_func=handle_errors,\n                dec_args=[\"Failed to show settings\"],\n                dec_kwargs=dict(\n                    handle_exc_class=SettingsError,\n                    unwrap_message=False,\n                    debug=True,\n                ),\n                is_simple=False,\n            ),\n            DecDef(\n                dec_func=attach_settings,\n                dec_args=[settings_model],\n                dec_kwargs=dict(validation=Validation.NEVER, persist=False, show=True),\n                is_simple=False,\n            ),\n        ],\n        include_context=True,\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.add_unset","title":"add_unset","text":"<pre><code>add_unset(cli: Typer, settings_model: type[BaseModel])\n</code></pre> <p>Add the <code>unset</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_unset(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add the `unset` command to the given `typer` app.\n    \"\"\"\n    opt_defs: list[OptDef] = []\n    for name, field_info in settings_model.model_fields.items():\n        opt_defs.append(\n            OptDef(\n                name=name,\n                param_type=bool,\n                default=False,\n                help=field_info.description,\n                show_default=True,\n                override_name=name,\n            )\n        )\n    build_command(\n        cli,\n        unset,\n        *opt_defs,\n        decorators=[\n            DecDef(\n                dec_func=handle_errors,\n                dec_args=[\"Failed to unset settings\"],\n                dec_kwargs=dict(\n                    handle_exc_class=SettingsError,\n                    unwrap_message=False,\n                    debug=True,\n                ),\n                is_simple=False,\n            ),\n            DecDef(\n                dec_func=attach_settings,\n                dec_args=[settings_model],\n                dec_kwargs=dict(validation=Validation.NEVER, persist=True, show=True),\n                is_simple=False,\n            ),\n        ],\n        include_context=True,\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.add_update","title":"add_update","text":"<pre><code>add_update(cli: Typer, settings_model: type[BaseModel])\n</code></pre> <p>Add the <code>update</code> command to the given <code>typer</code> app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def add_update(cli: typer.Typer, settings_model: type[BaseModel]):\n    \"\"\"\n    Add the `update` command to the given `typer` app.\n    \"\"\"\n    opt_defs: list[OptDef] = []\n    for name, field_info in settings_model.model_fields.items():\n        param_type: type[Any] = SettingsError.enforce_defined(field_info.annotation, \"Option type may not be `None`\")\n        default: None | bool = None\n        opt_kwargs: dict[str, Any] = dict(\n            name=name,\n            param_type=param_type | None,\n            default=default,\n            help=field_info.description,\n            show_default=True,\n        )\n        if param_type is bool:\n            default = field_info.default\n        elif issubclass(param_type, BaseModel):\n            model_type = param_type\n            def model_parser(val: str):\n                \"\"\"\n                Provide a parser that converts a string into an instance of the nested model.\n\n                This is needed for the settings commands to be able to use nested pydantic models.\n                \"\"\"\n                return model_type(**json.loads(val))\n            opt_kwargs[\"parser\"] = model_parser\n\n        opt_defs.append(OptDef(**opt_kwargs))\n    build_command(\n        cli,\n        update,\n        *opt_defs,\n        decorators=[\n            DecDef(\n                dec_func=handle_errors,\n                dec_args=[\"Failed to update settings\"],\n                dec_kwargs=dict(\n                    handle_exc_class=SettingsError,\n                    unwrap_message=False,\n                    debug=True,\n                ),\n                is_simple=False,\n            ),\n            DecDef(\n                dec_func=attach_settings,\n                dec_args=[settings_model],\n                dec_kwargs=dict(validation=Validation.NEVER, persist=True, show=True),\n                is_simple=False,\n            ),\n        ],\n        include_context=True,\n    )\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.bind","title":"bind","text":"<pre><code>bind(ctx: Context)\n</code></pre> <p>Bind all settings for the app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def bind(ctx: typer.Context):\n    \"\"\"\n    Bind all settings for the app.\n    \"\"\"\n    __manager: SettingsManager = get_settings_manager(ctx)\n    excluded_locals = [\"__manager\", \"ctx\"]\n    settings_values = {k: v for (k, v) in locals().items() if k not in excluded_locals}\n    __manager.update(**settings_values)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.reset","title":"reset","text":"<pre><code>reset(ctx: Context)\n</code></pre> <p>Remove all settings from the app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def reset(ctx: typer.Context):\n    \"\"\"\n    Remove all settings from the app.\n    \"\"\"\n    typer.confirm(\"Are you sure you want to reset your settings?\", abort=True)\n    __manager: SettingsManager = get_settings_manager(ctx)\n    __manager.reset()\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.show","title":"show","text":"<pre><code>show(ctx: Context)\n</code></pre> <p>Show the current app's settings.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def show(ctx: typer.Context):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Show the current app's settings.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.unset","title":"unset","text":"<pre><code>unset(ctx: Context)\n</code></pre> <p>Remove some settings from the app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def unset(ctx: typer.Context):\n    \"\"\"\n    Remove some settings from the app.\n    \"\"\"\n    __manager: SettingsManager = get_settings_manager(ctx)\n    excluded_locals = [\"__manager\", \"ctx\"]\n    settings_values = {k: v for (k, v) in locals().items() if k not in excluded_locals and v}\n    __manager.unset(*settings_values.keys())\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.commands.update","title":"update","text":"<pre><code>update(ctx: Context)\n</code></pre> <p>Update some settings for the app.</p> Source code in <code>src/typerdrive/settings/commands.py</code> <pre><code>def update(ctx: typer.Context):\n    \"\"\"\n    Update some settings for the app.\n    \"\"\"\n    __manager: SettingsManager = get_settings_manager(ctx)\n    excluded_locals = [\"__manager\", \"ctx\"]\n    settings_values = {k: v for (k, v) in locals().items() if k not in excluded_locals and v is not None}\n    __manager.update(**settings_values)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions","title":"typerdrive.settings.exceptions","text":"<p>Provide exceptions specific to the settings feature of <code>typerdrive</code>.</p>"},{"location":"reference/settings/#typerdrive.settings.exceptions-classes","title":"Classes","text":""},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsError","title":"SettingsError","text":"<p>               Bases: <code>TyperdriveError</code></p> <p>The base exception for settings errors.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsError(TyperdriveError):\n    \"\"\"\n    The base exception for settings errors.\n    \"\"\"\n    exit_code: ExitCode = ExitCode.GENERAL_ERROR\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsError-attributes","title":"Attributes","text":""},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsError.exit_code","title":"exit_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_code: ExitCode = GENERAL_ERROR\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsInitError","title":"SettingsInitError","text":"<p>               Bases: <code>SettingsError</code></p> <p>Indicates that there was a problem initializing the settings.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsInitError(SettingsError):\n    \"\"\"\n    Indicates that there was a problem initializing the settings.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsResetError","title":"SettingsResetError","text":"<p>               Bases: <code>SettingsError</code></p> <p>Indicates that there was a problem resetting a settings value.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsResetError(SettingsError):\n    \"\"\"\n    Indicates that there was a problem resetting a settings value.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsSaveError","title":"SettingsSaveError","text":"<p>               Bases: <code>SettingsError</code></p> <p>Indicates that there was a problem saving the settings to disk.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsSaveError(SettingsError):\n    \"\"\"\n    Indicates that there was a problem saving the settings to disk.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsUnsetError","title":"SettingsUnsetError","text":"<p>               Bases: <code>SettingsError</code></p> <p>Indicates that there was a problem unsetting a settings value.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsUnsetError(SettingsError):\n    \"\"\"\n    Indicates that there was a problem unsetting a settings value.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.exceptions.SettingsUpdateError","title":"SettingsUpdateError","text":"<p>               Bases: <code>SettingsError</code></p> <p>Indicates that there was a problem updating a settings value.</p> Source code in <code>src/typerdrive/settings/exceptions.py</code> <pre><code>class SettingsUpdateError(SettingsError):\n    \"\"\"\n    Indicates that there was a problem updating a settings value.\n    \"\"\"\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager","title":"typerdrive.settings.manager","text":"<p>Provide a class for managing the <code>typerdrive</code> settings feature.</p>"},{"location":"reference/settings/#typerdrive.settings.manager-classes","title":"Classes","text":""},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager","title":"SettingsManager","text":"<p>Manage settings for the <code>typerdrive</code> app.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>class SettingsManager:\n    \"\"\"\n    Manage settings for the `typerdrive` app.\n    \"\"\"\n\n    settings_model: type[BaseModel]\n    \"\"\" A `pydantic` model _type_ that defines the app's settings \"\"\"\n\n    settings_path: Path\n    \"\"\" The path to the file where settings are persisted \"\"\"\n\n    invalid_warnings: dict[str, str]\n    \"\"\" Tracks which fields of the settings instance are invalid \"\"\"\n\n    settings_instance: BaseModel\n    \"\"\" An instance of the `settings_model` that holds the app's current settings \"\"\"\n\n    def __init__(self, settings_model: type[BaseModel]):\n        config: TyperdriveConfig = get_typerdrive_config()\n\n        self.settings_model = settings_model\n        self.settings_path = config.settings_path\n        self.invalid_warnings = {}\n\n        with SettingsInitError.handle_errors(\"Failed to initialize settings\"):\n            settings_values: dict[str, Any] = {}\n            if self.settings_path.exists():\n                settings_values = json.loads(self.settings_path.read_text())\n            try:\n                self.settings_instance = self.settings_model(**settings_values)\n            except ValidationError as err:\n                self.settings_instance = self.settings_model.model_construct(**settings_values)\n                self.set_warnings(err)\n\n    def set_warnings(self, err: ValidationError):\n        \"\"\"\n        Given a `ValidationError`, extract the field names and messages to the `invalid_warnings` dict.\n        \"\"\"\n        self.invalid_warnings = {}\n        for data in err.errors():\n            key: str = cast(str, data[\"loc\"][0])\n            message = data[\"msg\"]\n            self.invalid_warnings[key] = message\n\n    def update(self, **settings_values: Any):\n        \"\"\"\n        Update the app settings given the provided key/value pairs.\n\n        If validation fails, the `invalid_warngings` will be updated, but all valid fields will remain set.\n        \"\"\"\n        logger.debug(f\"Updating settings with {settings_values}\")\n\n        with SettingsUpdateError.handle_errors(\"Failed to update settings\"):\n            combined_settings = {**self.settings_instance.model_dump(), **settings_values}\n            try:\n                self.settings_instance = self.settings_model(**combined_settings)\n                self.invalid_warnings = {}\n            except ValidationError as err:\n                self.settings_instance = self.settings_model.model_construct(**combined_settings)\n                self.set_warnings(err)\n\n    def unset(self, *unset_keys: str):\n        \"\"\"\n        Remove all the settings corresponding to the provided keys.\n        \"\"\"\n        logger.debug(f\"Unsetting keys {unset_keys}\")\n\n        with SettingsUnsetError.handle_errors(\"Failed to remove keys\"):\n            settings_values = {k: v for (k, v) in self.settings_instance.model_dump().items() if k not in unset_keys}\n            try:\n                self.settings_instance = self.settings_model(**settings_values)\n                self.invalid_warnings = {}\n            except ValidationError as err:\n                self.settings_instance = self.settings_model.model_construct(**settings_values)\n                self.set_warnings(err)\n\n    def reset(self):\n        \"\"\"\n        Reset the settings back to defaults.\n        \"\"\"\n        logger.debug(\"Resetting all settings\")\n\n        with SettingsResetError.handle_errors(\"Failed to reset settings\"):\n            try:\n                self.settings_instance = self.settings_model()\n                self.invalid_warnings = {}\n            except ValidationError as err:\n                self.settings_instance = self.settings_model.model_construct()\n                self.set_warnings(err)\n\n    def validate(self):\n        \"\"\"\n        Validate the current settings values.\n\n        If invalid, `ValidationError` exceptions will be raised\n        \"\"\"\n        self.settings_model(**self.settings_instance.model_dump())\n\n    def pretty(self, with_style: bool = True) -&gt; str:\n        \"\"\"\n        Return a pretty representation of the settings.\n        \"\"\"\n        (bold_, _bold) = (\"[bold]\", \"[/bold]\") if with_style else (\"\", \"\")\n        (red_, _red) = (\"[red]\", \"[/red]\") if with_style else (\"\", \"\")\n        lines: list[str] = []\n        parts: list[tuple[str, Any]] = []\n        for field_name in self.settings_instance.__class__.model_fields:\n            if field_name == \"invalid_warning\":\n                continue\n            try:\n                field_string = str(getattr(self.settings_instance, field_name))\n            except AttributeError:\n                field_string = \"&lt;UNSET&gt;\"\n            if field_name in self.invalid_warnings:\n                field_string = f\"{red_}{field_string}{_red}\"\n            parts.append((dasherize(field_name), field_string))\n\n        max_field_len = max(len(field_name) for field_name, _ in parts)\n        lines.extend(f\"{bold_}{k:&gt;{max_field_len}}{_bold} -&gt; {v}\" for k, v in parts)\n\n        if self.invalid_warnings:\n            lines.append(\"\")\n            lines.append(f\"{red_}Settings are invalid:{_red}\")\n            lines.extend(\n                f\"{bold_}{dasherize(k):&gt;{max_field_len}}{_bold} -&gt; {v}\" for k, v in self.invalid_warnings.items()\n            )\n\n        return \"\\n\".join(lines)\n\n    def save(self):\n        \"\"\"\n        Write the current settings to disk.\n        \"\"\"\n        logger.debug(f\"Saving settings to {self.settings_path}\")\n\n        with SettingsSaveError.handle_errors(f\"Failed to save settings to {self.settings_path}\"):\n            self.settings_path.parent.mkdir(parents=True, exist_ok=True)\n            self.settings_path.write_text(self.settings_instance.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager-attributes","title":"Attributes","text":""},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.invalid_warnings","title":"invalid_warnings  <code>instance-attribute</code>","text":"<pre><code>invalid_warnings: dict[str, str] = {}\n</code></pre> <p>Tracks which fields of the settings instance are invalid</p>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.settings_instance","title":"settings_instance  <code>instance-attribute</code>","text":"<pre><code>settings_instance: BaseModel = settings_model(\n    **settings_values\n)\n</code></pre> <p>An instance of the <code>settings_model</code> that holds the app's current settings</p>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.settings_model","title":"settings_model  <code>instance-attribute</code>","text":"<pre><code>settings_model: type[BaseModel] = settings_model\n</code></pre> <p>A <code>pydantic</code> model type that defines the app's settings</p>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.settings_path","title":"settings_path  <code>instance-attribute</code>","text":"<pre><code>settings_path: Path = settings_path\n</code></pre> <p>The path to the file where settings are persisted</p>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager-functions","title":"Functions","text":""},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.__init__","title":"__init__","text":"<pre><code>__init__(settings_model: type[BaseModel])\n</code></pre> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def __init__(self, settings_model: type[BaseModel]):\n    config: TyperdriveConfig = get_typerdrive_config()\n\n    self.settings_model = settings_model\n    self.settings_path = config.settings_path\n    self.invalid_warnings = {}\n\n    with SettingsInitError.handle_errors(\"Failed to initialize settings\"):\n        settings_values: dict[str, Any] = {}\n        if self.settings_path.exists():\n            settings_values = json.loads(self.settings_path.read_text())\n        try:\n            self.settings_instance = self.settings_model(**settings_values)\n        except ValidationError as err:\n            self.settings_instance = self.settings_model.model_construct(**settings_values)\n            self.set_warnings(err)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.pretty","title":"pretty","text":"<pre><code>pretty(with_style: bool = True) -&gt; str\n</code></pre> <p>Return a pretty representation of the settings.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def pretty(self, with_style: bool = True) -&gt; str:\n    \"\"\"\n    Return a pretty representation of the settings.\n    \"\"\"\n    (bold_, _bold) = (\"[bold]\", \"[/bold]\") if with_style else (\"\", \"\")\n    (red_, _red) = (\"[red]\", \"[/red]\") if with_style else (\"\", \"\")\n    lines: list[str] = []\n    parts: list[tuple[str, Any]] = []\n    for field_name in self.settings_instance.__class__.model_fields:\n        if field_name == \"invalid_warning\":\n            continue\n        try:\n            field_string = str(getattr(self.settings_instance, field_name))\n        except AttributeError:\n            field_string = \"&lt;UNSET&gt;\"\n        if field_name in self.invalid_warnings:\n            field_string = f\"{red_}{field_string}{_red}\"\n        parts.append((dasherize(field_name), field_string))\n\n    max_field_len = max(len(field_name) for field_name, _ in parts)\n    lines.extend(f\"{bold_}{k:&gt;{max_field_len}}{_bold} -&gt; {v}\" for k, v in parts)\n\n    if self.invalid_warnings:\n        lines.append(\"\")\n        lines.append(f\"{red_}Settings are invalid:{_red}\")\n        lines.extend(\n            f\"{bold_}{dasherize(k):&gt;{max_field_len}}{_bold} -&gt; {v}\" for k, v in self.invalid_warnings.items()\n        )\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the settings back to defaults.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the settings back to defaults.\n    \"\"\"\n    logger.debug(\"Resetting all settings\")\n\n    with SettingsResetError.handle_errors(\"Failed to reset settings\"):\n        try:\n            self.settings_instance = self.settings_model()\n            self.invalid_warnings = {}\n        except ValidationError as err:\n            self.settings_instance = self.settings_model.model_construct()\n            self.set_warnings(err)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.save","title":"save","text":"<pre><code>save()\n</code></pre> <p>Write the current settings to disk.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def save(self):\n    \"\"\"\n    Write the current settings to disk.\n    \"\"\"\n    logger.debug(f\"Saving settings to {self.settings_path}\")\n\n    with SettingsSaveError.handle_errors(f\"Failed to save settings to {self.settings_path}\"):\n        self.settings_path.parent.mkdir(parents=True, exist_ok=True)\n        self.settings_path.write_text(self.settings_instance.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.set_warnings","title":"set_warnings","text":"<pre><code>set_warnings(err: ValidationError)\n</code></pre> <p>Given a <code>ValidationError</code>, extract the field names and messages to the <code>invalid_warnings</code> dict.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def set_warnings(self, err: ValidationError):\n    \"\"\"\n    Given a `ValidationError`, extract the field names and messages to the `invalid_warnings` dict.\n    \"\"\"\n    self.invalid_warnings = {}\n    for data in err.errors():\n        key: str = cast(str, data[\"loc\"][0])\n        message = data[\"msg\"]\n        self.invalid_warnings[key] = message\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.unset","title":"unset","text":"<pre><code>unset(*unset_keys: str)\n</code></pre> <p>Remove all the settings corresponding to the provided keys.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def unset(self, *unset_keys: str):\n    \"\"\"\n    Remove all the settings corresponding to the provided keys.\n    \"\"\"\n    logger.debug(f\"Unsetting keys {unset_keys}\")\n\n    with SettingsUnsetError.handle_errors(\"Failed to remove keys\"):\n        settings_values = {k: v for (k, v) in self.settings_instance.model_dump().items() if k not in unset_keys}\n        try:\n            self.settings_instance = self.settings_model(**settings_values)\n            self.invalid_warnings = {}\n        except ValidationError as err:\n            self.settings_instance = self.settings_model.model_construct(**settings_values)\n            self.set_warnings(err)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.update","title":"update","text":"<pre><code>update(**settings_values: Any)\n</code></pre> <p>Update the app settings given the provided key/value pairs.</p> <p>If validation fails, the <code>invalid_warngings</code> will be updated, but all valid fields will remain set.</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def update(self, **settings_values: Any):\n    \"\"\"\n    Update the app settings given the provided key/value pairs.\n\n    If validation fails, the `invalid_warngings` will be updated, but all valid fields will remain set.\n    \"\"\"\n    logger.debug(f\"Updating settings with {settings_values}\")\n\n    with SettingsUpdateError.handle_errors(\"Failed to update settings\"):\n        combined_settings = {**self.settings_instance.model_dump(), **settings_values}\n        try:\n            self.settings_instance = self.settings_model(**combined_settings)\n            self.invalid_warnings = {}\n        except ValidationError as err:\n            self.settings_instance = self.settings_model.model_construct(**combined_settings)\n            self.set_warnings(err)\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager.SettingsManager.validate","title":"validate","text":"<pre><code>validate()\n</code></pre> <p>Validate the current settings values.</p> <p>If invalid, <code>ValidationError</code> exceptions will be raised</p> Source code in <code>src/typerdrive/settings/manager.py</code> <pre><code>def validate(self):\n    \"\"\"\n    Validate the current settings values.\n\n    If invalid, `ValidationError` exceptions will be raised\n    \"\"\"\n    self.settings_model(**self.settings_instance.model_dump())\n</code></pre>"},{"location":"reference/settings/#typerdrive.settings.manager-functions","title":"Functions","text":""}]}